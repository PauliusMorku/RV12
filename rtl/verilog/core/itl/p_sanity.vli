/*////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

                           d8b 888             
                           Y8P 888             
                               888             
.d8888b   8888b.  88888b.  888 888888 888  888 
88K          "88b 888 "88b 888 888    888  888 
"Y8888b. .d888888 888  888 888 888    888  888 
     X88 888  888 888  888 888 Y88b.  Y88b 888 
 88888P' "Y888888 888  888 888  "Y888  "Y88888 
                                           888 
                                      Y8b d88P 
                                       "Y88P"  

*/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

property sanity;
dependencies: c_no_reset, c_no_debug, c_32bit_instr_only, c_no_st_flush, c_imem_response, c_imem_fairness, c_dmem_response, c_dmem_fairness;
for timepoints:
	// t1 detection
	t1_PF_rx_n = t,
	t1_PF_tx_f = t + 0..v_examination_window waits_for complete mg_tn_PF_tx(1),
	t1_IF_rx_f = t + 0..v_examination_window waits_for complete mg_tn_IF_rx(1),
	t1_IF_tx_f = t + 0..v_examination_window waits_for complete mg_tn_IF_tx(1),
	t1_ID_rx_f = t + 0..v_examination_window waits_for complete mg_tn_ID_rx(1),
	t1_ID_tx_f = t + 0..v_examination_window waits_for complete mg_tn_ID_tx(1),
	t1_EX_rx_f = t + 0..v_examination_window waits_for complete mg_tn_EX_rx(1),
	t1_EX_tx_f = t + 0..v_examination_window waits_for complete mg_tn_EX_tx(1),
	t1_ME_rx_f = t + 0..v_examination_window waits_for complete mg_tn_ME_rx(1),
	t1_ME_tx_f = t + 0..v_examination_window waits_for complete mg_tn_ME_tx(1),
	t1_WB_rx_f = t + 0..v_examination_window waits_for complete mg_tn_WB_rx(1),
	t1_WB_tx_f = t + 0..v_examination_window waits_for complete mg_tn_WB_tx(1),

	// t2 detection
	t2_PF_rx_n = t + 0..v_examination_window waits_for complete mg_tn_PF_rx(2),

	t_dummy = t; // last dummy line (for the semicolon)

freeze:
	at_t1_PF_tx_exist = mg_tn_PF_tx(1)@t1_PF_tx_f,
	at_t1_IF_rx_exist = mg_tn_IF_rx(1)@t1_IF_rx_f,
	at_t1_IF_tx_exist = mg_tn_IF_tx(1)@t1_IF_tx_f,
	at_t1_ID_rx_exist = mg_tn_ID_rx(1)@t1_ID_rx_f,
	at_t1_ID_tx_exist = mg_tn_ID_tx(1)@t1_ID_tx_f,
	at_t1_EX_rx_exist = mg_tn_EX_rx(1)@t1_EX_rx_f,
	at_t1_EX_tx_exist = mg_tn_EX_tx(1)@t1_EX_tx_f,
	at_t1_ME_rx_exist = mg_tn_ME_rx(1)@t1_ME_rx_f,
	at_t1_ME_tx_exist = mg_tn_ME_tx(1)@t1_ME_tx_f,
	at_t1_WB_rx_exist = mg_tn_WB_rx(1)@t1_WB_rx_f,
	at_t1_WB_tx_exist = mg_tn_WB_tx(1)@t1_WB_tx_f,

	at_t_dummy = clk@t_dummy; // last dummy line (for the semicolon)

assume:
	// Property is triggered whenever a token enters first pipeline stage
	at t1_PF_rx_n: mg_tn_PF_rx(1);

	// Configure token counters
    at t: PF_wcnt == 0;
	at t: IF_wcnt == 0;
	at t: ID_wcnt == 0;
	at t: EX_wcnt == 0;
	at t: ME_wcnt == 0;
	at t: WB_wcnt == 0;

	during[t,t+v_examination_window]: PF_wcnt_inc == m_PF_rx;
	during[t,t+v_examination_window]: IF_wcnt_inc == m_IF_rx;
	during[t,t+v_examination_window]: ID_wcnt_inc == m_ID_rx;
	during[t,t+v_examination_window]: EX_wcnt_inc == m_EX_rx;
	during[t,t+v_examination_window]: ME_wcnt_inc == m_ME_rx;
	during[t,t+v_examination_window]: WB_wcnt_inc == m_WB_rx;

	during[t,t+v_examination_window]: PF_trem == m_PF_tx;
	during[t,t+v_examination_window]: IF_trem == m_IF_tx;
	during[t,t+v_examination_window]: ID_trem == m_ID_tx;
	during[t,t+v_examination_window]: EX_trem == m_EX_tx;
	during[t,t+v_examination_window]: ME_trem == m_ME_tx;
	during[t,t+v_examination_window]: WB_trem == m_WB_tx;

prove:
	// Prove right hook
	at t2_PF_rx_n: mg_tn_PF_rx(2);

	// Same token is never transmited twice
	during[t,t+v_examination_window]: !(mg_tn_PF_tx(1) && (PF_tcnt == 0));
	during[t,t+v_examination_window]: !(mg_tn_IF_tx(1) && (IF_tcnt == 0));
	during[t,t+v_examination_window]: !(mg_tn_ID_tx(1) && (ID_tcnt == 0));
	during[t,t+v_examination_window]: !(mg_tn_EX_tx(1) && (EX_tcnt == 0));
	during[t,t+v_examination_window]: !(mg_tn_ME_tx(1) && (ME_tcnt == 0));
	during[t,t+v_examination_window]: !(mg_tn_WB_tx(1) && (WB_tcnt == 0));

	// Same token is never at two stages at the same time
	during[t,t+v_examination_window]: if (PF_tcnt != 0) PF_tcnt != IF_tcnt endif;
	during[t,t+v_examination_window]: if (IF_tcnt != 0) IF_tcnt != ID_tcnt endif;
	during[t,t+v_examination_window]: if (ID_tcnt != 0) ID_tcnt != EX_tcnt endif;
	during[t,t+v_examination_window]: if (EX_tcnt != 0) EX_tcnt != ME_tcnt endif;
	during[t,t+v_examination_window]: if (ME_tcnt != 0) ME_tcnt != WB_tcnt endif;

	// Each transaction of a token exists only if a previous transaction exists
	at t: if (at_t1_IF_rx_exist) at_t1_PF_tx_exist endif;
	at t: if (at_t1_IF_tx_exist) at_t1_IF_rx_exist endif;
	at t: if (at_t1_ID_rx_exist) at_t1_IF_tx_exist endif;
	at t: if (at_t1_ID_tx_exist) at_t1_ID_rx_exist endif;
	at t: if (at_t1_EX_rx_exist) at_t1_ID_tx_exist endif;
	at t: if (at_t1_EX_tx_exist) at_t1_EX_rx_exist endif;
	at t: if (at_t1_ME_rx_exist) at_t1_EX_tx_exist endif;
	at t: if (at_t1_ME_tx_exist) at_t1_ME_rx_exist endif;
	at t: if (at_t1_WB_rx_exist) at_t1_ME_tx_exist endif;
	at t: if (at_t1_WB_tx_exist) at_t1_WB_rx_exist endif;

	// Verifying that each transaction actually exists
	// at t1_PF_tx_f: if (at_t1_PF_tx_exist) mg_tn_PF_tx(1) endif;
	// at t1_IF_rx_f: if (at_t1_IF_rx_exist) mg_tn_IF_rx(1) endif;
	// at t1_IF_tx_f: if (at_t1_IF_tx_exist) mg_tn_IF_tx(1) endif;
	// at t1_ID_rx_f: if (at_t1_ID_rx_exist) mg_tn_ID_rx(1) endif;
	// at t1_ID_tx_f: if (at_t1_ID_tx_exist) mg_tn_ID_tx(1) endif;
	// at t1_EX_rx_f: if (at_t1_EX_rx_exist) mg_tn_EX_rx(1) endif;
	// at t1_EX_tx_f: if (at_t1_EX_tx_exist) mg_tn_EX_tx(1) endif;
	// at t1_ME_rx_f: if (at_t1_ME_rx_exist) mg_tn_ME_rx(1) endif;
	// at t1_ME_tx_f: if (at_t1_ME_tx_exist) mg_tn_ME_tx(1) endif;
	// at t1_WB_rx_f: if (at_t1_WB_rx_exist) mg_tn_WB_rx(1) endif;
	// at t1_WB_tx_f: if (at_t1_WB_tx_exist) mg_tn_WB_tx(1) endif;

end property;
