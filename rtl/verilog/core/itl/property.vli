/*
TODO:
	-try to match windows exactly (remove overlap)
*/
/*
c_imem_response_complex, c_dmem_response_complex:
im	dm	ew
0	0	12	
1	1	17
2	1	20	
2	2	22

c_imem_response_simple, c_dmem_response_simple:
im	dm	ew
0	0	12	
1	1	17
2	1	20
2	2	22
*/
macro unsigned v_imem_slack := 2 end macro;
macro unsigned v_dmem_slack := 2 end macro;
macro unsigned v_examination_window := 25 end macro;

/*////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
             _               _                               _                     _    
 __      __ (_)  _ __     __| |   ___   __      __     ___  | |__     ___    ___  | | __
 \ \ /\ / / | | | '_ \   / _` |  / _ \  \ \ /\ / /    / __| | '_ \   / _ \  / __| | |/ /
  \ V  V /  | | | | | | | (_| | | (_) |  \ V  V /    | (__  | | | | |  __/ | (__  |   < 
   \_/\_/   |_| |_| |_|  \__,_|  \___/    \_/\_/      \___| |_| |_|  \___|  \___| |_|\_\
                                                                                        
*/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

property window_check;
dependencies: c_no_debug, c_no_exception, c_no_st_flush, c_imem_response_simple, c_dmem_response_simple;

for timepoints:
	t2_IF_tx_f = t + 0..v_examination_window waits_for complete mg_tn_IF_tx(2),
	t2_ID_tx_f = t + 0..v_examination_window waits_for complete mg_tn_ID_tx(2),
	t2_EX_tx_f = t + 0..v_examination_window waits_for complete mg_tn_EX_tx(2),
	t2_ME_tx_f = t + 0..v_examination_window waits_for complete mg_tn_ME_tx(2),
	t2_WB_tx_f = t + 0..v_examination_window waits_for complete mg_tn_WB_tx(2),

	t_dummy = t; // last dummy line (for the semicolon)

freeze:
	at_t2_IF_tx_exist = mg_tn_IF_tx(2)@t2_IF_tx_f,
	at_t2_ID_tx_exist = mg_tn_ID_tx(2)@t2_ID_tx_f,
	at_t2_EX_tx_exist = mg_tn_EX_tx(2)@t2_EX_tx_f,
	at_t2_ME_tx_exist = mg_tn_ME_tx(2)@t2_ME_tx_f,
	at_t2_WB_tx_exist = mg_tn_WB_tx(2)@t2_WB_tx_f,

	at_t_dummy = clk@t_dummy; // last dummy line (for the semicolon)

assume:

	// Need separate property to check each stage tx case
	// TODO: Find a simple way to combine these assumptions?
	// Note that each tx has to be the first occurance otherwise the property is not correct

	// at t+v_examination_window: mg_tn_IF_tx(2);
	// during[t,t+v_examination_window-1]: !mg_tn_IF_tx(2);

	// at t+v_examination_window: mg_tn_ID_tx(2);
	// during[t,t+v_examination_window-1]: !mg_tn_ID_tx(2);

	// at t+v_examination_window: mg_tn_EX_tx(2);
	// during[t,t+v_examination_window-1]: !mg_tn_EX_tx(2);

	// at t+v_examination_window: mg_tn_ME_tx(2);
	// during[t,t+v_examination_window-1]: !mg_tn_ME_tx(2);

	// at t+v_examination_window: mg_tn_WB_tx(2);
	// during[t,t+v_examination_window-1]: !mg_tn_WB_tx(2);



	at t+v_examination_window: (
			fell(next(t2_IF_tx_wait)) || 
			fell(next(t2_ID_tx_wait)) || 
			fell(next(t2_EX_tx_wait)) || 
			fell(next(t2_ME_tx_wait)) || 
			fell(next(t2_WB_tx_wait))
		);

	// Configure transaction flag variables
	mg_flag_define(t2_IF_tx_wait, at_t2_IF_tx_exist, v_examination_window, t2_IF_tx_f);
	mg_flag_define(t2_ID_tx_wait, at_t2_ID_tx_exist, v_examination_window, t2_ID_tx_f);
	mg_flag_define(t2_EX_tx_wait, at_t2_EX_tx_exist, v_examination_window, t2_EX_tx_f);
	mg_flag_define(t2_ME_tx_wait, at_t2_ME_tx_exist, v_examination_window, t2_ME_tx_f);
	mg_flag_define(t2_WB_tx_wait, at_t2_WB_tx_exist, v_examination_window, t2_WB_tx_f);	

    // Configure token counters, note that IF_wcnt is not fixed on purpose since the property goes backwards. Fixing it would cause property to be unreachable
    at t: ID_wcnt == 0;
	at t: EX_wcnt == 0;
	at t: ME_wcnt == 0;
	at t: WB_wcnt == 0;

	during[t,t+v_examination_window]: IF_wcnt_inc == m_IF_rx;
	during[t,t+v_examination_window]: ID_wcnt_inc == m_ID_rx;
	during[t,t+v_examination_window]: EX_wcnt_inc == m_EX_rx;
	during[t,t+v_examination_window]: ME_wcnt_inc == m_ME_rx;
	during[t,t+v_examination_window]: WB_wcnt_inc == m_WB_rx;

	during[t,t+v_examination_window]: IF_trem == m_IF_tx;
	during[t,t+v_examination_window]: ID_trem == m_ID_tx;
	during[t,t+v_examination_window]: EX_trem == m_EX_tx;
	during[t,t+v_examination_window]: ME_trem == m_ME_tx;
	during[t,t+v_examination_window]: WB_trem == m_WB_tx;

	// Configure reset overlap
	during[t,t+v_examination_window]: !rose(m_rst); // Once the reset is released it can not be triggered again

prove:
	within[t,t+v_examination_window]: mg_tn_IF_rx(1);

end property;

/*////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  _                          
 | |__     __ _   ___    ___ 
 | '_ \   / _` | / __|  / _ \
 | |_) | | (_| | \__ \ |  __/
 |_.__/   \__,_| |___/  \___|
                             
*/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

property base;
dependencies: c_no_reset, c_no_debug, c_no_exception, c_no_st_flush, c_imem_response_simple, c_dmem_response_simple;
for timepoints:
	t1_IF_rx_f = t + 0..v_examination_window waits_for complete mg_tn_IF_rx(1),

	t1_IF_tx_f = t + 0..v_examination_window waits_for complete mg_tn_IF_tx(1),
	t1_IF_tx_l1 = t + 0..v_examination_window waits_for complete next(!t1_IF_tx_wait),
	t1_IF_tx_l = max_timepoint(t1_IF_tx_l1, t1_IF_rx_f),

	t1_IF_wn_l = t,
	t1_IF_wn_r = t + 0..v_examination_window waits_for complete (next(IF_wcnt) > 1),

	t1_ID_rx_f = t + 0..v_examination_window waits_for complete mg_tn_ID_rx(1),
	t1_ID_rx_l1 = t + 0..v_examination_window waits_for complete next(!t1_ID_rx_wait),
	t1_ID_rx_l = max_timepoint(t1_ID_rx_l1, t1_IF_tx_l), 

	t1_ID_tx_f = t + 0..v_examination_window waits_for complete mg_tn_ID_tx(1),
	t1_ID_tx_l1 = t + 0..v_examination_window waits_for complete next(!t1_ID_tx_wait),
	t1_ID_tx_l = max_timepoint(t1_ID_tx_l1, t1_ID_rx_l),

	t1_EX_rx_f = t + 0..v_examination_window waits_for complete mg_tn_EX_rx(1),
	t1_EX_rx_l1 = t + 0..v_examination_window waits_for complete next(!t1_EX_rx_wait),
	t1_EX_rx_l = max_timepoint(t1_EX_rx_l1, t1_ID_tx_l),

	t1_EX_tx_f = t + 0..v_examination_window waits_for complete mg_tn_EX_tx(1),
	t1_EX_tx_l1 = t + 0..v_examination_window waits_for complete next(!t1_EX_tx_wait),
	t1_EX_tx_l = max_timepoint(t1_EX_tx_l1, t1_EX_rx_l),

	t1_ME_rx_f = t + 0..v_examination_window waits_for complete mg_tn_ME_rx(1),
	t1_ME_rx_l1 = t + 0..v_examination_window waits_for complete next(!t1_ME_rx_wait),
	t1_ME_rx_l = max_timepoint(t1_ME_rx_l1, t1_EX_tx_l),

	t1_ME_tx_f = t + 0..v_examination_window waits_for complete mg_tn_ME_tx(1),
	t1_ME_tx_l1 = t + 0..v_examination_window waits_for complete next(!t1_ME_tx_wait),
	t1_ME_tx_l = max_timepoint(t1_ME_tx_l1, t1_ME_rx_l),

	t1_WB_rx_f = t + 0..v_examination_window waits_for complete mg_tn_WB_rx(1),
	t1_WB_rx_l1 = t + 0..v_examination_window waits_for complete next(!t1_WB_rx_wait),
	t1_WB_rx_l = max_timepoint(t1_WB_rx_l1, t1_ME_tx_l),

	t1_WB_tx_f = t + 0..v_examination_window waits_for complete mg_tn_WB_tx(1),
	t1_WB_tx_l1 = t + 0..v_examination_window waits_for complete next(!t1_WB_tx_wait),
	t1_WB_tx_l = max_timepoint(t1_WB_tx_l1, t1_WB_rx_l),


	t1_flush_f = t + 0..v_examination_window waits_for complete mg_tn_flush(1),

	t_dummy = t; // last dummy line (for the semicolon)

freeze:
	at_t1_IF_tx_exist = mg_tn_IF_tx(1)@t1_IF_tx_f,
	at_t1_ID_rx_exist = mg_tn_ID_rx(1)@t1_ID_rx_f,
	at_t1_ID_tx_exist = mg_tn_ID_tx(1)@t1_ID_tx_f,
	at_t1_EX_rx_exist = mg_tn_EX_rx(1)@t1_EX_rx_f,
	at_t1_EX_tx_exist = mg_tn_EX_tx(1)@t1_EX_tx_f,
	at_t1_ME_rx_exist = mg_tn_ME_rx(1)@t1_ME_rx_f,
	at_t1_ME_tx_exist = mg_tn_ME_tx(1)@t1_ME_tx_f,
	at_t1_WB_rx_exist = mg_tn_WB_rx(1)@t1_WB_rx_f,
	at_t1_WB_tx_exist = mg_tn_WB_tx(1)@t1_WB_tx_f,

	at_t_dummy = clk@t_dummy; // last dummy line (for the semicolon)

assume:
    reset_sequence;

	// Configure transaction flag variables
	mg_flag_define(t1_IF_tx_wait, at_t1_IF_tx_exist, v_examination_window, t1_IF_tx_f);
	mg_flag_define(t1_ID_rx_wait, at_t1_ID_rx_exist, v_examination_window, t1_ID_rx_f);
	mg_flag_define(t1_ID_tx_wait, at_t1_ID_tx_exist, v_examination_window, t1_ID_tx_f);
	mg_flag_define(t1_EX_rx_wait, at_t1_EX_rx_exist, v_examination_window, t1_EX_rx_f);
	mg_flag_define(t1_EX_tx_wait, at_t1_EX_tx_exist, v_examination_window, t1_EX_tx_f);
	mg_flag_define(t1_ME_rx_wait, at_t1_ME_rx_exist, v_examination_window, t1_ME_rx_f);
	mg_flag_define(t1_ME_tx_wait, at_t1_ME_tx_exist, v_examination_window, t1_ME_tx_f);
	mg_flag_define(t1_WB_rx_wait, at_t1_WB_rx_exist, v_examination_window, t1_WB_rx_f);
	mg_flag_define(t1_WB_tx_wait, at_t1_WB_tx_exist, v_examination_window, t1_WB_tx_f);

    // Configure token counters
	at t: IF_wcnt == 0;
	at t: ID_wcnt == 0;
	at t: EX_wcnt == 0;
	at t: ME_wcnt == 0;
	at t: WB_wcnt == 0;

	during[t,t+v_examination_window]: IF_wcnt_inc == m_IF_rx;
	during[t,t+v_examination_window]: ID_wcnt_inc == m_ID_rx;
	during[t,t+v_examination_window]: EX_wcnt_inc == m_EX_rx;
	during[t,t+v_examination_window]: ME_wcnt_inc == m_ME_rx;
	during[t,t+v_examination_window]: WB_wcnt_inc == m_WB_rx;

	during[t,t+v_examination_window]: IF_trem == m_IF_tx;
	during[t,t+v_examination_window]: ID_trem == m_ID_tx;
	during[t,t+v_examination_window]: EX_trem == m_EX_tx;
	during[t,t+v_examination_window]: ME_trem == m_ME_tx;
	during[t,t+v_examination_window]: WB_trem == m_WB_tx;

	// For debugging
	during[t,t+v_examination_window]: IF_instr_enum == getInstr(m_IF_instr);
	during[t,t+v_examination_window]: ID_instr_enum == getInstr(m_ID_instr);
	during[t,t+v_examination_window]: EX_instr_enum == getInstr(m_EX_instr);
	during[t,t+v_examination_window]: ME_instr_enum == getInstr(m_ME_instr);
	during[t,t+v_examination_window]: WB_instr_enum == getInstr(m_WB_instr);

prove:
	at t1_IF_rx_f: mg_tn_IF_rx(1);
	at t1_flush_f: mg_tn_flush(1) == false;

	//at t1_IF_tx_f: m_IF_pc == PC_INIT;
	at t1_IF_tx_f: m_IF_instr == prev(c/if_unit/pd_instr);

end property;

/*////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
   __   _                 _                _                     _    
  / _| | |  _   _   ___  | |__       ___  | |__     ___    ___  | | __
 | |_  | | | | | | / __| | '_ \     / __| | '_ \   / _ \  / __| | |/ /
 |  _| | | | |_| | \__ \ | | | |   | (__  | | | | |  __/ | (__  |   < 
 |_|   |_|  \__,_| |___/ |_| |_|    \___| |_| |_|  \___|  \___| |_|\_\
                                                                      
*/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

property flush_check;
dependencies: c_no_reset, c_no_debug, c_no_exception, c_no_st_flush, c_imem_response, c_dmem_response;
for timepoints:
	t1_IF_rx_n = t + 0..v_examination_window waits_for complete mg_tn_IF_rx(1),
	t2_IF_rx_n = t + 0..v_examination_window waits_for complete mg_tn_IF_rx(2),
	t3_IF_rx_n = t + 0..v_examination_window waits_for complete mg_tn_IF_rx(3),
	t4_IF_rx_n = t + 0..v_examination_window waits_for complete mg_tn_IF_rx(4),
	t5_IF_rx_n = t + 0..v_examination_window waits_for complete mg_tn_IF_rx(5),

	t1_flush_f = t + 0..v_examination_window waits_for complete mg_tn_flush(1),
	t2_flush_f = t + 0..v_examination_window waits_for complete mg_tn_flush(2),
	t3_flush_f = t + 0..v_examination_window waits_for complete mg_tn_flush(3),
	t4_flush_f = t + 0..v_examination_window waits_for complete mg_tn_flush(4),
	t5_flush_f = t + 0..v_examination_window waits_for complete mg_tn_flush(5),

	t_dummy = t; // last dummy line (for the semicolon)

freeze:
	// Freeze signals indicating flushing cases
	at_t1_flush_exist = mg_tn_flush(1)@t1_flush_f,
	at_t2_flush_exist = mg_tn_flush(2)@t2_flush_f,
	at_t3_flush_exist = mg_tn_flush(3)@t3_flush_f,
	at_t4_flush_exist = mg_tn_flush(4)@t4_flush_f,
	at_t5_flush_exist = mg_tn_flush(5)@t5_flush_f,

	at_t_dummy = clk@t_dummy; // last dummy line (for the semicolon)

assume:
	// Property is triggered whenever a token enters first pipeline stage
	at t1_IF_rx_n: mg_tn_IF_rx(1);

	// Make sure that property does not start at flushing
	at t: !at_t1_flush_exist;

    // Configure token counters
	at t: IF_wcnt == 0;
	at t: ID_wcnt == 0;
	at t: EX_wcnt == 0;
	at t: ME_wcnt == 0;
	at t: WB_wcnt == 0;

	during[t,t+v_examination_window]: IF_wcnt_inc == m_IF_rx;
	during[t,t+v_examination_window]: ID_wcnt_inc == m_ID_rx;
	during[t,t+v_examination_window]: EX_wcnt_inc == m_EX_rx;
	during[t,t+v_examination_window]: ME_wcnt_inc == m_ME_rx;
	during[t,t+v_examination_window]: WB_wcnt_inc == m_WB_rx;

	during[t,t+v_examination_window]: IF_trem == m_IF_tx;
	during[t,t+v_examination_window]: ID_trem == m_ID_tx;
	during[t,t+v_examination_window]: EX_trem == m_EX_tx;
	during[t,t+v_examination_window]: ME_trem == m_ME_tx;
	during[t,t+v_examination_window]: WB_trem == m_WB_tx;

	// For debugging
	during[t,t+v_examination_window]: IF_instr_enum == getInstr(m_IF_instr);
	during[t,t+v_examination_window]: ID_instr_enum == getInstr(m_ID_instr);
	during[t,t+v_examination_window]: EX_instr_enum == getInstr(m_EX_instr);
	during[t,t+v_examination_window]: ME_instr_enum == getInstr(m_ME_instr);
	during[t,t+v_examination_window]: WB_instr_enum == getInstr(m_WB_instr);

prove:
	at t: !at_t2_flush_exist || !at_t3_flush_exist || !at_t4_flush_exist || !at_t5_flush_exist;

	at t1_IF_rx_n: mg_tn_IF_rx(1);
	at t2_IF_rx_n: if (at_t1_flush_exist) mg_tn_IF_rx(2) endif;
	at t3_IF_rx_n: if (at_t1_flush_exist && at_t2_flush_exist) mg_tn_IF_rx(3) endif;
	at t4_IF_rx_n: if (at_t1_flush_exist && at_t2_flush_exist && at_t3_flush_exist) mg_tn_IF_rx(4) endif;
	at t5_IF_rx_n: if (at_t1_flush_exist && at_t2_flush_exist && at_t3_flush_exist && at_t4_flush_exist) mg_tn_IF_rx(5) endif;

	// Prove that counters do not overflow
	during[t,t+v_examination_window]: next(IF_wcnt) >= IF_wcnt;
	during[t,t+v_examination_window]: next(ID_wcnt) >= ID_wcnt;
	during[t,t+v_examination_window]: next(EX_wcnt) >= EX_wcnt;
	during[t,t+v_examination_window]: next(ME_wcnt) >= ME_wcnt;
	during[t,t+v_examination_window]: next(WB_wcnt) >= WB_wcnt;

end property;

/*////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                        _   _           
  ___    __ _   _ __   (_) | |_   _   _ 
 / __|  / _` | | '_ \  | | | __| | | | |
 \__ \ | (_| | | | | | | | | |_  | |_| |
 |___/  \__,_| |_| |_| |_|  \__|  \__, |
                                  |___/ 
*/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
property sanity;
dependencies: c_no_reset, c_no_debug, c_no_exception, c_no_st_flush, c_imem_response_simple, c_dmem_response_simple;
for timepoints:
	// t1 detection
	t1_IF_rx_n = t,
	t1_IF_tx_f = t + 0..v_examination_window waits_for complete mg_tn_IF_tx(1),
	t1_ID_rx_f = t + 0..v_examination_window waits_for complete mg_tn_ID_rx(1),
	t1_ID_tx_f = t + 0..v_examination_window waits_for complete mg_tn_ID_tx(1),
	t1_EX_rx_f = t + 0..v_examination_window waits_for complete mg_tn_EX_rx(1),
	t1_EX_tx_f = t + 0..v_examination_window waits_for complete mg_tn_EX_tx(1),
	t1_ME_rx_f = t + 0..v_examination_window waits_for complete mg_tn_ME_rx(1),
	t1_ME_tx_f = t + 0..v_examination_window waits_for complete mg_tn_ME_tx(1),
	t1_WB_rx_f = t + 0..v_examination_window waits_for complete mg_tn_WB_rx(1),
	t1_WB_tx_f = t + 0..v_examination_window waits_for complete mg_tn_WB_tx(1),

	// t2 detection
	t2_IF_rx_n = t + 0..v_examination_window waits_for complete mg_tn_IF_rx(2),

	t_dummy = t; // last dummy line (for the semicolon)

freeze:
	at_t1_IF_tx_exist = mg_tn_IF_tx(1)@t1_IF_tx_f,
	at_t1_ID_rx_exist = mg_tn_ID_rx(1)@t1_ID_rx_f,
	at_t1_ID_tx_exist = mg_tn_ID_tx(1)@t1_ID_tx_f,
	at_t1_EX_rx_exist = mg_tn_EX_rx(1)@t1_EX_rx_f,
	at_t1_EX_tx_exist = mg_tn_EX_tx(1)@t1_EX_tx_f,
	at_t1_ME_rx_exist = mg_tn_ME_rx(1)@t1_ME_rx_f,
	at_t1_ME_tx_exist = mg_tn_ME_tx(1)@t1_ME_tx_f,
	at_t1_WB_rx_exist = mg_tn_WB_rx(1)@t1_WB_rx_f,
	at_t1_WB_tx_exist = mg_tn_WB_tx(1)@t1_WB_tx_f,

	at_t_dummy = clk@t_dummy; // last dummy line (for the semicolon)

assume:
	// Property is triggered whenever a token enters first pipeline stage
	at t1_IF_rx_n: mg_tn_IF_rx(1);

	// Configure token counters
	at t: IF_wcnt == 0;
	at t: ID_wcnt == 0;
	at t: EX_wcnt == 0;
	at t: ME_wcnt == 0;
	at t: WB_wcnt == 0;

	during[t,t+v_examination_window]: IF_wcnt_inc == m_IF_rx;
	during[t,t+v_examination_window]: ID_wcnt_inc == m_ID_rx;
	during[t,t+v_examination_window]: EX_wcnt_inc == m_EX_rx;
	during[t,t+v_examination_window]: ME_wcnt_inc == m_ME_rx;
	during[t,t+v_examination_window]: WB_wcnt_inc == m_WB_rx;

prove:
	// Prove right hook
	at t2_IF_rx_n: mg_tn_IF_rx(2);

	// Sanity checks
	at t: if (at_t1_ID_rx_exist) at_t1_IF_tx_exist endif;
	at t: if (at_t1_ID_tx_exist) at_t1_ID_rx_exist endif;
	at t: if (at_t1_EX_rx_exist) at_t1_ID_tx_exist endif;
	at t: if (at_t1_EX_tx_exist) at_t1_EX_rx_exist endif;
	at t: if (at_t1_ME_rx_exist) at_t1_EX_tx_exist endif;
	at t: if (at_t1_ME_tx_exist) at_t1_ME_rx_exist endif;
	at t: if (at_t1_WB_rx_exist) at_t1_ME_tx_exist endif;
	at t: if (at_t1_WB_tx_exist) at_t1_WB_rx_exist endif;

	at t1_IF_tx_f: if (at_t1_IF_tx_exist) mg_tn_IF_tx(1) endif;
	at t1_ID_rx_f: if (at_t1_ID_rx_exist) mg_tn_ID_rx(1) endif;
	at t1_ID_tx_f: if (at_t1_ID_tx_exist) mg_tn_ID_tx(1) endif;
	at t1_EX_rx_f: if (at_t1_EX_rx_exist) mg_tn_EX_rx(1) endif;
	at t1_EX_tx_f: if (at_t1_EX_tx_exist) mg_tn_EX_tx(1) endif;
	at t1_ME_rx_f: if (at_t1_ME_rx_exist) mg_tn_ME_rx(1) endif;
	at t1_ME_tx_f: if (at_t1_ME_tx_exist) mg_tn_ME_tx(1) endif;
	at t1_WB_rx_f: if (at_t1_WB_rx_exist) mg_tn_WB_rx(1) endif;
	at t1_WB_tx_f: if (at_t1_WB_tx_exist) mg_tn_WB_tx(1) endif;

end property;


property mem_sanity;
dependencies: c_imem_response, c_dmem_response;
assume:
	at t: mg_tn_IF_rx(1);

	//within[t,t+15]: if_parcel_valid == 2'b01;
	//within[t,t+v_examination_window]: dmem_ack;
	//during[t,t+v_examination_window]: !dmem_req;

	during[t,t+v_examination_window]: IF_wcnt_inc == m_IF_rx;


prove:
	at t: true;

end property;

/*////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        _                  
  ___  | |_    ___   _ __  
 / __| | __|  / _ \ | '_ \ 
 \__ \ | |_  |  __/ | |_) |
 |___/  \__|  \___| | .__/ 
                    |_|    
*/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

property step;
dependencies: c_no_reset, c_no_debug, c_no_exception, c_no_st_flush, c_imem_response_simple, c_dmem_response_simple;
for timepoints:

	// This code detects last use of the stage that can come from either t1 or some older token if t1 contains skipped stages
	// tl detection
	tl_IF_tx_f = t + 0..v_examination_window waits_for complete mg_tl_IF_tx,
	tl_IF_tx_l = t + 0..v_examination_window waits_for complete next(!tl_IF_tx_wait), // Occurance after t

	tl_ID_rx_f = t + 0..v_examination_window waits_for complete mg_tl_ID_rx,
	tl_ID_rx_l1 = t + 0..v_examination_window waits_for complete next(!tl_ID_rx_wait), // Occurance after tl_IF_tx_l
	tl_ID_rx_l = max_timepoint(tl_ID_rx_l1, tl_IF_tx_l), 

	tl_ID_tx_f = t + 0..v_examination_window waits_for complete mg_tl_ID_tx,
	tl_ID_tx_l1 = t + 0..v_examination_window waits_for complete next(!tl_ID_tx_wait), // Occurance after tl_ID_rx_l1+1
	tl_ID_tx_l = max_timepoint(tl_ID_tx_l1, tl_ID_rx_l),

	tl_EX_rx_f = t + 0..v_examination_window waits_for complete mg_tl_EX_rx,
	tl_EX_rx_l1 = t + 0..v_examination_window waits_for complete next(!tl_EX_rx_wait), // Occurance after tl_ID_tx_l
	tl_EX_rx_l = max_timepoint(tl_EX_rx_l1, tl_ID_tx_l),

	tl_EX_tx_f = t + 0..v_examination_window waits_for complete mg_tl_EX_tx,
	tl_EX_tx_l1 = t + 0..v_examination_window waits_for complete next(!tl_EX_tx_wait), // Occurance after tl_EX_rx_l1+1
	tl_EX_tx_l = max_timepoint(tl_EX_tx_l1, tl_EX_rx_l),

	tl_ME_rx_f = t + 0..v_examination_window waits_for complete mg_tl_ME_rx,
	tl_ME_rx_l1 = t + 0..v_examination_window waits_for complete next(!tl_ME_rx_wait), // Occurance after tl_EX_tx_l1
	tl_ME_rx_l = max_timepoint(tl_ME_rx_l1, tl_EX_tx_l),

	tl_ME_tx_f = t + 0..v_examination_window waits_for complete mg_tl_ME_tx,
	tl_ME_tx_l1 = t + 0..v_examination_window waits_for complete next(!tl_ME_tx_wait), // Occurance after tl_ME_rx_l1+1
	tl_ME_tx_l = max_timepoint(tl_ME_tx_l1, tl_ME_rx_l),

	tl_WB_rx_f = t + 0..v_examination_window waits_for complete mg_tl_WB_rx,
	tl_WB_rx_l1 = t + 0..v_examination_window waits_for complete next(!tl_WB_rx_wait), // Occurance after tl_ME_tx_l1
	tl_WB_rx_l = max_timepoint(tl_WB_rx_l1, tl_ME_tx_l),

	tl_WB_tx_f = t + 0..v_examination_window waits_for complete mg_tl_WB_tx,
	tl_WB_tx_l1 = t + 0..v_examination_window waits_for complete next(!tl_WB_tx_wait), // Occurance after tl_WB_rx_l1+1
	tl_WB_tx_l = max_timepoint(tl_WB_tx_l1, tl_WB_rx_l),


	// t1 detection
	t1_IF_rx_n = t,

	// t2 detection
	t2_IF_rx_n = t + 0..v_examination_window waits_for complete mg_tn_IF_rx(2),

	t2_IF_tx_f = t + 0..v_examination_window waits_for complete mg_tn_IF_tx(2),
	t2_IF_tx_l1 = t + 0..v_examination_window waits_for complete next(!t2_IF_tx_wait),
	t2_IF_tx_l = max_timepoint(t2_IF_tx_l1, t2_IF_rx_n),

	t2_IF_wn_l = t2_IF_rx_n,
	t2_IF_wn_r = t + 0..v_examination_window waits_for complete (next(IF_wcnt) > 2),

	t2_ID_rx_f = t + 0..v_examination_window waits_for complete mg_tn_ID_rx(2),
	t2_ID_rx_l1 = t + 0..v_examination_window waits_for complete next(!t2_ID_rx_wait),
	t2_ID_rx_l2 = max_timepoint(t2_ID_rx_l1, t2_IF_tx_l),
	t2_ID_rx_l = max_timepoint(t2_ID_rx_l2, tl_EX_rx_l),

	t2_ID_tx_f = t + 0..v_examination_window waits_for complete mg_tn_ID_tx(2),
	t2_ID_tx_l1 = t + 0..v_examination_window waits_for complete next(!t2_ID_tx_wait),
	t2_ID_tx_l = max_timepoint(t2_ID_tx_l1, t2_ID_rx_l),

	t2_ID_wn_l = t2_ID_rx_l,
	t2_ID_wn_r = t + 0..v_examination_window waits_for complete (next(ID_wcnt) > 2),

	t2_EX_rx_f = t + 0..v_examination_window waits_for complete mg_tn_EX_rx(2),
	t2_EX_rx_l1 = t + 0..v_examination_window waits_for complete next(!t2_EX_rx_wait),
	t2_EX_rx_l2 = max_timepoint(t2_EX_rx_l1, t2_ID_tx_l),
	t2_EX_rx_l = max_timepoint(t2_EX_rx_l2, tl_ME_rx_l),

	t2_EX_tx_f = t + 0..v_examination_window waits_for complete mg_tn_EX_tx(2),
	t2_EX_tx_l1 = t + 0..v_examination_window waits_for complete next(!t2_EX_tx_wait),
	t2_EX_tx_l = max_timepoint(t2_EX_tx_l1, t2_EX_rx_l),

	t2_EX_wn_l = t2_EX_rx_l,
	t2_EX_wn_r = t + 0..v_examination_window waits_for complete (next(EX_wcnt) > 2),

	t2_ME_rx_f = t + 0..v_examination_window waits_for complete mg_tn_ME_rx(2),
	t2_ME_rx_l1 = t + 0..v_examination_window waits_for complete next(!t2_ME_rx_wait),
	t2_ME_rx_l2 = max_timepoint(t2_ME_rx_l1, t2_EX_tx_l),
	t2_ME_rx_l = max_timepoint(t2_ME_rx_l2, tl_WB_rx_l),

	t2_ME_tx_f = t + 0..v_examination_window waits_for complete mg_tn_ME_tx(2),
	t2_ME_tx_l1 = t + 0..v_examination_window waits_for complete next(!t2_ME_tx_wait),
	t2_ME_tx_l = max_timepoint(t2_ME_tx_l1, t2_ME_rx_l),

	t2_ME_wn_l = t2_ME_rx_l,
	t2_ME_wn_r = t + 0..v_examination_window waits_for complete (next(ME_wcnt) > 2),

	t2_WB_rx_f = t + 0..v_examination_window waits_for complete mg_tn_WB_rx(2),
	t2_WB_rx_l1 = t + 0..v_examination_window waits_for complete next(!t2_WB_rx_wait),
	t2_WB_rx_l2 = max_timepoint(t2_WB_rx_l1, t2_ME_tx_l),
	t2_WB_rx_l = max_timepoint(t2_WB_rx_l2, tl_WB_tx_l), // special case since it is the last pipeline stage

	t2_WB_tx_f = t + 0..v_examination_window waits_for complete mg_tn_WB_tx(2),

	t2_WB_wn_l = t2_WB_rx_l,
	t2_WB_wn_r = t + 0..v_examination_window waits_for complete (next(WB_wcnt) > 2),


	// Detect flushing cases
	t1_flush_f = t + 0..v_examination_window waits_for complete mg_tn_flush(1),
	t2_flush_f = t + 0..v_examination_window waits_for complete mg_tn_flush(2),
	t3_flush_f = t + 0..v_examination_window waits_for complete mg_tn_flush(3),
	t4_flush_f = t + 0..v_examination_window waits_for complete mg_tn_flush(4),
	t5_flush_f = t + 0..v_examination_window waits_for complete mg_tn_flush(5),

	t_dummy = t; // last dummy line (for the semicolon)

freeze:
	at_tl_IF_tx_exist = mg_tl_IF_tx@tl_IF_tx_f,
	at_tl_ID_rx_exist = mg_tl_ID_rx@tl_ID_rx_f,
	at_tl_ID_tx_exist = mg_tl_ID_tx@tl_ID_tx_f,
	at_tl_EX_rx_exist = mg_tl_EX_rx@tl_EX_rx_f,
	at_tl_EX_tx_exist = mg_tl_EX_tx@tl_EX_tx_f,
	at_tl_ME_rx_exist = mg_tl_ME_rx@tl_ME_rx_f,
	at_tl_ME_tx_exist = mg_tl_ME_tx@tl_ME_tx_f,
	at_tl_WB_rx_exist = mg_tl_WB_rx@tl_WB_rx_f,
	at_tl_WB_tx_exist = mg_tl_WB_tx@tl_WB_tx_f,

	at_t2_IF_tx_exist = mg_tn_IF_tx(2)@t2_IF_tx_f,
	at_t2_ID_rx_exist = mg_tn_ID_rx(2)@t2_ID_rx_f,
	at_t2_ID_tx_exist = mg_tn_ID_tx(2)@t2_ID_tx_f,
	at_t2_EX_rx_exist = mg_tn_EX_rx(2)@t2_EX_rx_f,
	at_t2_EX_tx_exist = mg_tn_EX_tx(2)@t2_EX_tx_f,
	at_t2_ME_rx_exist = mg_tn_ME_rx(2)@t2_ME_rx_f,
	at_t2_ME_tx_exist = mg_tn_ME_tx(2)@t2_ME_tx_f,
	at_t2_WB_rx_exist = mg_tn_WB_rx(2)@t2_WB_rx_f,
	at_t2_WB_tx_exist = mg_tn_WB_tx(2)@t2_WB_tx_f,

	at_t2_IF_tx_instr = m_IF_instr@t2_IF_tx_f,
	at_t2_ID_tx_instr = m_ID_instr@t2_ID_tx_f,
	at_t2_EX_tx_instr = m_EX_instr@t2_EX_tx_f,
	at_t2_ME_tx_instr = m_ME_instr@t2_ME_tx_f,
	at_t2_WB_tx_instr = m_WB_instr@t2_WB_tx_f,

	at_t2_IF_tx_pc = m_IF_pc@t2_IF_tx_f,
	at_t2_ID_tx_pc = m_ID_pc@t2_ID_tx_f,
	at_t2_EX_tx_pc = m_EX_pc@t2_EX_tx_f,
	at_t2_ME_tx_pc = m_ME_pc@t2_ME_tx_f,
	at_t2_WB_tx_pc = m_WB_pc@t2_WB_tx_f,

	at_t_dummy = clk@t_dummy; // last dummy line (for the semicolon)

assume:
	// Property is triggered whenever a token enters first pipeline stage
	at t1_IF_rx_n: mg_tn_IF_rx(1);

	// Define flushing scenario
	at t1_flush_f: mg_tn_flush(1) == false;
	at t2_flush_f: mg_tn_flush(2) == false;

	//within[t,t+5]: m_IF_tx && !m_ID_rx;
	//within[t,t+15]: if_parcel_valid == 2'b01;

	// Configure token counters
	at t: IF_wcnt == 0;
	at t: ID_wcnt == 0;
	at t: EX_wcnt == 0;
	at t: ME_wcnt == 0;
	at t: WB_wcnt == 0;

	during[t,t+v_examination_window]: IF_wcnt_inc == m_IF_rx;
	during[t,t+v_examination_window]: ID_wcnt_inc == m_ID_rx;
	during[t,t+v_examination_window]: EX_wcnt_inc == m_EX_rx;
	during[t,t+v_examination_window]: ME_wcnt_inc == m_ME_rx;
	during[t,t+v_examination_window]: WB_wcnt_inc == m_WB_rx;

	during[t,t+v_examination_window]: IF_trem == m_IF_tx;
	during[t,t+v_examination_window]: ID_trem == m_ID_tx;
	during[t,t+v_examination_window]: EX_trem == m_EX_tx;
	during[t,t+v_examination_window]: ME_trem == m_ME_tx;
	during[t,t+v_examination_window]: WB_trem == m_WB_tx;

	// Configure transaction flag variables
	mg_flag_define(tl_IF_tx_wait, at_tl_IF_tx_exist, v_examination_window, tl_IF_tx_f);
	mg_flag_define(tl_ID_rx_wait, at_tl_ID_rx_exist, v_examination_window, tl_ID_rx_f);
	mg_flag_define(tl_ID_tx_wait, at_tl_ID_tx_exist, v_examination_window, tl_ID_tx_f);
	mg_flag_define(tl_EX_rx_wait, at_tl_EX_rx_exist, v_examination_window, tl_EX_rx_f);
	mg_flag_define(tl_EX_tx_wait, at_tl_EX_tx_exist, v_examination_window, tl_EX_tx_f);
	mg_flag_define(tl_ME_rx_wait, at_tl_ME_rx_exist, v_examination_window, tl_ME_rx_f);
	mg_flag_define(tl_ME_tx_wait, at_tl_ME_tx_exist, v_examination_window, tl_ME_tx_f);
	mg_flag_define(tl_WB_rx_wait, at_tl_WB_rx_exist, v_examination_window, tl_WB_rx_f);
	mg_flag_define(tl_WB_tx_wait, at_tl_WB_tx_exist, v_examination_window, tl_WB_tx_f);

	mg_flag_define(t2_IF_tx_wait, at_t2_IF_tx_exist, v_examination_window, t2_IF_tx_f);
	mg_flag_define(t2_ID_rx_wait, at_t2_ID_rx_exist, v_examination_window, t2_ID_rx_f);
	mg_flag_define(t2_ID_tx_wait, at_t2_ID_tx_exist, v_examination_window, t2_ID_tx_f);
	mg_flag_define(t2_EX_rx_wait, at_t2_EX_rx_exist, v_examination_window, t2_EX_rx_f);
	mg_flag_define(t2_EX_tx_wait, at_t2_EX_tx_exist, v_examination_window, t2_EX_tx_f);
	mg_flag_define(t2_ME_rx_wait, at_t2_ME_rx_exist, v_examination_window, t2_ME_rx_f);
	mg_flag_define(t2_ME_tx_wait, at_t2_ME_tx_exist, v_examination_window, t2_ME_tx_f);
	mg_flag_define(t2_WB_rx_wait, at_t2_WB_rx_exist, v_examination_window, t2_WB_rx_f);
	mg_flag_define(t2_WB_tx_wait, at_t2_WB_tx_exist, v_examination_window, t2_WB_tx_f);	

	// For debugging
	during[t,t+v_examination_window]: IF_instr_enum == getInstr(m_IF_instr);
	during[t,t+v_examination_window]: ID_instr_enum == getInstr(m_ID_instr);
	during[t,t+v_examination_window]: EX_instr_enum == getInstr(m_EX_instr);
	during[t,t+v_examination_window]: ME_instr_enum == getInstr(m_ME_instr);
	during[t,t+v_examination_window]: WB_instr_enum == getInstr(m_WB_instr);

//during[t,t+v_examination_window]: c/id_stall == 0;

prove:
	// Prove right hook
	at t2_IF_rx_n: mg_tn_IF_rx(2);

	at t2_ID_tx_f: if (at_t2_ID_tx_exist) m_ID_instr == at_t2_IF_tx_instr endif;
	at t2_EX_tx_f: if (at_t2_EX_tx_exist) m_EX_instr == at_t2_ID_tx_instr endif;
	at t2_ME_tx_f: if (at_t2_ME_tx_exist) m_ME_instr == at_t2_EX_tx_instr endif;
	at t2_WB_tx_f: if (at_t2_WB_tx_exist) m_WB_instr == at_t2_ME_tx_instr endif;

	at t2_ID_tx_f: if (at_t2_ID_tx_exist) m_ID_pc == at_t2_IF_tx_pc endif;
	at t2_EX_tx_f: if (at_t2_EX_tx_exist) m_EX_pc == at_t2_ID_tx_pc endif;
	at t2_ME_tx_f: if (at_t2_ME_tx_exist) m_ME_pc == at_t2_EX_tx_pc endif;
	at t2_WB_tx_f: if (at_t2_WB_tx_exist) m_WB_pc == at_t2_ME_tx_pc endif;

	at t2_ID_tx_f: if (getInstr(at_t2_IF_tx_instr) == JAL_INSTR)
			(m_ID_bu_nxt_pc == (at_t2_IF_tx_pc + getImmediate(at_t2_IF_tx_instr))[31:0]) &&
			(m_ID_bu_flush == true)
		endif;

	//at tl_ID_tx_f: at_t2_IF_tx_pc == m_ID_bu_nxt_pc;// fails because of pc fetching from memory

	// at tl_ID_tx_f: if (getInstr(m_ID_instr) == JAL_INSTR)
	// 		(at_t2_IF_tx_pc == m_ID_bu_nxt_pc)
	// 	endif;


end property;

/*////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        _                       __   _ 
  ___  | |_    ___   _ __      / _| / |
 / __| | __|  / _ \ | '_ \    | |_  | |
 \__ \ | |_  |  __/ | |_) |   |  _| | |
 |___/  \__|  \___| | .__/    |_|   |_|
                    |_|                
*/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

macro unsigned v_examination_window_f1 := 30 end macro;

property step_f1;
dependencies: c_no_reset, c_no_debug, c_no_exception, c_no_st_flush, c_imem_response_simple, c_dmem_response_simple;
for timepoints:

	// This code detects last use of the stage that can come from either t1 or some older token if t1 contains skipped stages
	// tl detection
	tl_IF_tx_f = t + 0..v_examination_window_f1 waits_for complete mg_tl_IF_tx,
	tl_IF_tx_l = t + 0..v_examination_window_f1 waits_for complete next(!tl_IF_tx_wait), // Occurance after t

	tl_ID_rx_f = t + 0..v_examination_window_f1 waits_for complete mg_tl_ID_rx,
	tl_ID_rx_l1 = t + 0..v_examination_window_f1 waits_for complete next(!tl_ID_rx_wait), // Occurance after tl_IF_tx_l
	tl_ID_rx_l = max_timepoint(tl_ID_rx_l1, tl_IF_tx_l), 

	tl_ID_tx_f = t + 0..v_examination_window_f1 waits_for complete mg_tl_ID_tx,
	tl_ID_tx_l1 = t + 0..v_examination_window_f1 waits_for complete next(!tl_ID_tx_wait), // Occurance after tl_ID_rx_l1+1
	tl_ID_tx_l = max_timepoint(tl_ID_tx_l1, tl_ID_rx_l),

	tl_EX_rx_f = t + 0..v_examination_window_f1 waits_for complete mg_tl_EX_rx,
	tl_EX_rx_l1 = t + 0..v_examination_window_f1 waits_for complete next(!tl_EX_rx_wait), // Occurance after tl_ID_tx_l
	tl_EX_rx_l = max_timepoint(tl_EX_rx_l1, tl_ID_tx_l),

	tl_EX_tx_f = t + 0..v_examination_window_f1 waits_for complete mg_tl_EX_tx,
	tl_EX_tx_l1 = t + 0..v_examination_window_f1 waits_for complete next(!tl_EX_tx_wait), // Occurance after tl_EX_rx_l1+1
	tl_EX_tx_l = max_timepoint(tl_EX_tx_l1, tl_EX_rx_l),

	tl_ME_rx_f = t + 0..v_examination_window_f1 waits_for complete mg_tl_ME_rx,
	tl_ME_rx_l1 = t + 0..v_examination_window_f1 waits_for complete next(!tl_ME_rx_wait), // Occurance after tl_EX_tx_l1
	tl_ME_rx_l = max_timepoint(tl_ME_rx_l1, tl_EX_tx_l),

	tl_ME_tx_f = t + 0..v_examination_window_f1 waits_for complete mg_tl_ME_tx,
	tl_ME_tx_l1 = t + 0..v_examination_window_f1 waits_for complete next(!tl_ME_tx_wait), // Occurance after tl_ME_rx_l1+1
	tl_ME_tx_l = max_timepoint(tl_ME_tx_l1, tl_ME_rx_l),

	tl_WB_rx_f = t + 0..v_examination_window_f1 waits_for complete mg_tl_WB_rx,
	tl_WB_rx_l1 = t + 0..v_examination_window_f1 waits_for complete next(!tl_WB_rx_wait), // Occurance after tl_ME_tx_l1
	tl_WB_rx_l = max_timepoint(tl_WB_rx_l1, tl_ME_tx_l),

	tl_WB_tx_f = t + 0..v_examination_window_f1 waits_for complete mg_tl_WB_tx,
	tl_WB_tx_l1 = t + 0..v_examination_window_f1 waits_for complete next(!tl_WB_tx_wait), // Occurance after tl_WB_rx_l1+1
	tl_WB_tx_l = max_timepoint(tl_WB_tx_l1, tl_WB_rx_l),


	// t1 detection
	t1_IF_rx_n = t,

	// t2 detection
	t2_IF_rx_n = t + 0..v_examination_window_f1 waits_for complete mg_tn_IF_rx(2),

	t2_IF_tx_f = t + 0..v_examination_window_f1 waits_for complete mg_tn_IF_tx(2),
	t2_IF_tx_l1 = t + 0..v_examination_window_f1 waits_for complete next(!t2_IF_tx_wait),
	t2_IF_tx_l = max_timepoint(t2_IF_tx_l1, t2_IF_rx_n),

	t2_IF_wn_l = t2_IF_rx_n,
	t2_IF_wn_r = t + 0..v_examination_window_f1 waits_for complete (next(IF_wcnt) > 2),

	t2_ID_rx_f = t + 0..v_examination_window_f1 waits_for complete mg_tn_ID_rx(2),
	t2_ID_rx_l1 = t + 0..v_examination_window_f1 waits_for complete next(!t2_ID_rx_wait),
	t2_ID_rx_l2 = max_timepoint(t2_ID_rx_l1, t2_IF_tx_l),
	t2_ID_rx_l = max_timepoint(t2_ID_rx_l2, tl_EX_rx_l),

	t2_ID_tx_f = t + 0..v_examination_window_f1 waits_for complete mg_tn_ID_tx(2),
	t2_ID_tx_l1 = t + 0..v_examination_window_f1 waits_for complete next(!t2_ID_tx_wait),
	t2_ID_tx_l = max_timepoint(t2_ID_tx_l1, t2_ID_rx_l),

	t2_ID_wn_l = t2_ID_rx_l,
	t2_ID_wn_r = t + 0..v_examination_window_f1 waits_for complete (next(ID_wcnt) > 2),

	t2_EX_rx_f = t + 0..v_examination_window_f1 waits_for complete mg_tn_EX_rx(2),
	t2_EX_rx_l1 = t + 0..v_examination_window_f1 waits_for complete next(!t2_EX_rx_wait),
	t2_EX_rx_l2 = max_timepoint(t2_EX_rx_l1, t2_ID_tx_l),
	t2_EX_rx_l = max_timepoint(t2_EX_rx_l2, tl_ME_rx_l),

	t2_EX_tx_f = t + 0..v_examination_window_f1 waits_for complete mg_tn_EX_tx(2),
	t2_EX_tx_l1 = t + 0..v_examination_window_f1 waits_for complete next(!t2_EX_tx_wait),
	t2_EX_tx_l = max_timepoint(t2_EX_tx_l1, t2_EX_rx_l),

	t2_EX_wn_l = t2_EX_rx_l,
	t2_EX_wn_r = t + 0..v_examination_window_f1 waits_for complete (next(EX_wcnt) > 2),

	t2_ME_rx_f = t + 0..v_examination_window_f1 waits_for complete mg_tn_ME_rx(2),
	t2_ME_rx_l1 = t + 0..v_examination_window_f1 waits_for complete next(!t2_ME_rx_wait),
	t2_ME_rx_l2 = max_timepoint(t2_ME_rx_l1, t2_EX_tx_l),
	t2_ME_rx_l = max_timepoint(t2_ME_rx_l2, tl_WB_rx_l),

	t2_ME_tx_f = t + 0..v_examination_window_f1 waits_for complete mg_tn_ME_tx(2),
	t2_ME_tx_l1 = t + 0..v_examination_window_f1 waits_for complete next(!t2_ME_tx_wait),
	t2_ME_tx_l = max_timepoint(t2_ME_tx_l1, t2_ME_rx_l),

	t2_ME_wn_l = t2_ME_rx_l,
	t2_ME_wn_r = t + 0..v_examination_window_f1 waits_for complete (next(ME_wcnt) > 2),

	t2_WB_rx_f = t + 0..v_examination_window_f1 waits_for complete mg_tn_WB_rx(2),
	t2_WB_rx_l1 = t + 0..v_examination_window_f1 waits_for complete next(!t2_WB_rx_wait),
	t2_WB_rx_l2 = max_timepoint(t2_WB_rx_l1, t2_ME_tx_l),
	t2_WB_rx_l = max_timepoint(t2_WB_rx_l2, tl_WB_tx_l), // special case since it is the last pipeline stage

	t2_WB_tx_f = t + 0..v_examination_window_f1 waits_for complete mg_tn_WB_tx(2),
	t2_WB_tx_l1 = t + 0..v_examination_window_f1 waits_for complete next(!t2_WB_tx_wait),
	t2_WB_tx_l = max_timepoint(t2_WB_tx_l1, t2_WB_rx_l),

	t2_WB_wn_l = t2_WB_rx_l,
	t2_WB_wn_r = t + 0..v_examination_window_f1 waits_for complete (next(WB_wcnt) > 2),

	// t3 detection
	t3_IF_rx_n = t + 0..v_examination_window_f1 waits_for complete mg_tn_IF_rx(3),

	t3_IF_tx_f = t + 0..v_examination_window_f1 waits_for complete mg_tn_IF_tx(3),
	t3_IF_tx_l1 = t + 0..v_examination_window_f1 waits_for complete next(!t3_IF_tx_wait),
	t3_IF_tx_l = max_timepoint(t3_IF_tx_l1, t3_IF_rx_n),

	t3_IF_wn_l = t3_IF_rx_n,
	t3_IF_wn_r = t + 0..v_examination_window_f1 waits_for complete (next(IF_wcnt) > 3),

	t3_ID_rx_f = t + 0..v_examination_window_f1 waits_for complete mg_tn_ID_rx(3),
	t3_ID_rx_l1 = t + 0..v_examination_window_f1 waits_for complete next(!t3_ID_rx_wait),
	t3_ID_rx_l2 = max_timepoint(t3_ID_rx_l1, t3_IF_tx_l),
	t3_ID_rx_l = max_timepoint(t3_ID_rx_l2, t2_EX_rx_l),

	t3_ID_tx_f = t + 0..v_examination_window_f1 waits_for complete mg_tn_ID_tx(3),
	t3_ID_tx_l1 = t + 0..v_examination_window_f1 waits_for complete next(!t3_ID_tx_wait),
	t3_ID_tx_l = max_timepoint(t3_ID_tx_l1, t3_ID_rx_l),

	t3_ID_wn_l = t3_ID_rx_l,
	t3_ID_wn_r = t + 0..v_examination_window_f1 waits_for complete (next(ID_wcnt) > 3),

	t3_EX_rx_f = t + 0..v_examination_window_f1 waits_for complete mg_tn_EX_rx(3),
	t3_EX_rx_l1 = t + 0..v_examination_window_f1 waits_for complete next(!t3_EX_rx_wait),
	t3_EX_rx_l2 = max_timepoint(t3_EX_rx_l1, t3_ID_tx_l),
	t3_EX_rx_l = max_timepoint(t3_EX_rx_l2, t2_ME_rx_l),

	t3_EX_tx_f = t + 0..v_examination_window_f1 waits_for complete mg_tn_EX_tx(3),
	t3_EX_tx_l1 = t + 0..v_examination_window_f1 waits_for complete next(!t3_EX_tx_wait),
	t3_EX_tx_l = max_timepoint(t3_EX_tx_l1, t3_EX_rx_l),

	t3_EX_wn_l = t3_EX_rx_l,
	t3_EX_wn_r = t + 0..v_examination_window_f1 waits_for complete (next(EX_wcnt) > 3),

	t3_ME_rx_f = t + 0..v_examination_window_f1 waits_for complete mg_tn_ME_rx(3),
	t3_ME_rx_l1 = t + 0..v_examination_window_f1 waits_for complete next(!t3_ME_rx_wait),
	t3_ME_rx_l2 = max_timepoint(t3_ME_rx_l1, t3_EX_tx_l),
	t3_ME_rx_l = max_timepoint(t3_ME_rx_l2, t2_WB_rx_l),

	t3_ME_tx_f = t + 0..v_examination_window_f1 waits_for complete mg_tn_ME_tx(3),
	t3_ME_tx_l1 = t + 0..v_examination_window_f1 waits_for complete next(!t3_ME_tx_wait),
	t3_ME_tx_l = max_timepoint(t3_ME_tx_l1, t3_ME_rx_l),

	t3_ME_wn_l = t3_ME_rx_l,
	t3_ME_wn_r = t + 0..v_examination_window_f1 waits_for complete (next(ME_wcnt) > 3),

	t3_WB_rx_f = t + 0..v_examination_window_f1 waits_for complete mg_tn_WB_rx(3),
	t3_WB_rx_l1 = t + 0..v_examination_window_f1 waits_for complete next(!t3_WB_rx_wait),
	t3_WB_rx_l2 = max_timepoint(t3_WB_rx_l1, t3_ME_tx_l),
	t3_WB_rx_l = max_timepoint(t3_WB_rx_l2, t2_WB_tx_l), // special case since it is the last pipeline stage

	t3_WB_tx_f = t + 0..v_examination_window_f1 waits_for complete mg_tn_WB_tx(3),

	t3_WB_wn_l = t3_WB_rx_l,
	t3_WB_wn_r = t + 0..v_examination_window_f1 waits_for complete (next(WB_wcnt) > 3),


	// Detect flushing cases
	t1_flush_f = t + 0..v_examination_window_f1 waits_for complete mg_tn_flush(1),
	t2_flush_f = t + 0..v_examination_window_f1 waits_for complete mg_tn_flush(2),
	t3_flush_f = t + 0..v_examination_window_f1 waits_for complete mg_tn_flush(3),
	t4_flush_f = t + 0..v_examination_window_f1 waits_for complete mg_tn_flush(4),
	t5_flush_f = t + 0..v_examination_window_f1 waits_for complete mg_tn_flush(5),

	t_dummy = t; // last dummy line (for the semicolon)

freeze:
	at_tl_IF_tx_exist = mg_tl_IF_tx@tl_IF_tx_f,
	at_tl_ID_rx_exist = mg_tl_ID_rx@tl_ID_rx_f,
	at_tl_ID_tx_exist = mg_tl_ID_tx@tl_ID_tx_f,
	at_tl_EX_rx_exist = mg_tl_EX_rx@tl_EX_rx_f,
	at_tl_EX_tx_exist = mg_tl_EX_tx@tl_EX_tx_f,
	at_tl_ME_rx_exist = mg_tl_ME_rx@tl_ME_rx_f,
	at_tl_ME_tx_exist = mg_tl_ME_tx@tl_ME_tx_f,
	at_tl_WB_rx_exist = mg_tl_WB_rx@tl_WB_rx_f,
	at_tl_WB_tx_exist = mg_tl_WB_tx@tl_WB_tx_f,

	at_t2_IF_tx_exist = mg_tn_IF_tx(2)@t2_IF_tx_f,
	at_t2_ID_rx_exist = mg_tn_ID_rx(2)@t2_ID_rx_f,
	at_t2_ID_tx_exist = mg_tn_ID_tx(2)@t2_ID_tx_f,
	at_t2_EX_rx_exist = mg_tn_EX_rx(2)@t2_EX_rx_f,
	at_t2_EX_tx_exist = mg_tn_EX_tx(2)@t2_EX_tx_f,
	at_t2_ME_rx_exist = mg_tn_ME_rx(2)@t2_ME_rx_f,
	at_t2_ME_tx_exist = mg_tn_ME_tx(2)@t2_ME_tx_f,
	at_t2_WB_rx_exist = mg_tn_WB_rx(2)@t2_WB_rx_f,
	at_t2_WB_tx_exist = mg_tn_WB_tx(2)@t2_WB_tx_f,

	at_t3_IF_tx_exist = mg_tn_IF_tx(3)@t3_IF_tx_f,
	at_t3_ID_rx_exist = mg_tn_ID_rx(3)@t3_ID_rx_f,
	at_t3_ID_tx_exist = mg_tn_ID_tx(3)@t3_ID_tx_f,
	at_t3_EX_rx_exist = mg_tn_EX_rx(3)@t3_EX_rx_f,
	at_t3_EX_tx_exist = mg_tn_EX_tx(3)@t3_EX_tx_f,
	at_t3_ME_rx_exist = mg_tn_ME_rx(3)@t3_ME_rx_f,
	at_t3_ME_tx_exist = mg_tn_ME_tx(3)@t3_ME_tx_f,
	at_t3_WB_rx_exist = mg_tn_WB_rx(3)@t3_WB_rx_f,
	at_t3_WB_tx_exist = mg_tn_WB_tx(3)@t3_WB_tx_f,

	at_t3_IF_tx_instr = m_IF_instr@t3_IF_tx_f,
	at_t3_ID_tx_instr = m_ID_instr@t3_ID_tx_f,
	at_t3_EX_tx_instr = m_EX_instr@t3_EX_tx_f,
	at_t3_ME_tx_instr = m_ME_instr@t3_ME_tx_f,
	at_t3_WB_tx_instr = m_WB_instr@t3_WB_tx_f,

	at_t3_IF_tx_pc = m_IF_pc@t3_IF_tx_f,
	at_t3_ID_tx_pc = m_ID_pc@t3_ID_tx_f,
	at_t3_EX_tx_pc = m_EX_pc@t3_EX_tx_f,
	at_t3_ME_tx_pc = m_ME_pc@t3_ME_tx_f,
	at_t3_WB_tx_pc = m_WB_pc@t3_WB_tx_f,

	at_t_dummy = clk@t_dummy; // last dummy line (for the semicolon)

assume:
	// Property is triggered whenever a token enters first pipeline stage
	at t1_IF_rx_n: mg_tn_IF_rx(1);

	// Define flushing scenario
	at t1_flush_f: mg_tn_flush(1) == false;
	at t2_flush_f: mg_tn_flush(2) == true;
	at t3_flush_f: mg_tn_flush(3) == false;

	// Configure token counters
	at t: IF_wcnt == 0;
	during[t,t+v_examination_window_f1]: IF_wcnt_inc == m_IF_rx;
	at t: ID_wcnt == 0;
	during[t,t+v_examination_window_f1]: ID_wcnt_inc == m_ID_rx;
	at t: EX_wcnt == 0;
	during[t,t+v_examination_window_f1]: EX_wcnt_inc == m_EX_rx;
	at t: ME_wcnt == 0;
	during[t,t+v_examination_window_f1]: ME_wcnt_inc == m_ME_rx;
	at t: WB_wcnt == 0;
	during[t,t+v_examination_window_f1]: WB_wcnt_inc == m_WB_rx;

	during[t,t+v_examination_window]: IF_trem == m_IF_tx;
	during[t,t+v_examination_window]: ID_trem == m_ID_tx;
	during[t,t+v_examination_window]: EX_trem == m_EX_tx;
	during[t,t+v_examination_window]: ME_trem == m_ME_tx;
	during[t,t+v_examination_window]: WB_trem == m_WB_tx;

	// Configure transaction flag variables
	mg_flag_define(tl_IF_tx_wait, at_tl_IF_tx_exist, v_examination_window_f1, tl_IF_tx_f);
	mg_flag_define(tl_ID_rx_wait, at_tl_ID_rx_exist, v_examination_window_f1, tl_ID_rx_f);
	mg_flag_define(tl_ID_tx_wait, at_tl_ID_tx_exist, v_examination_window_f1, tl_ID_tx_f);
	mg_flag_define(tl_EX_rx_wait, at_tl_EX_rx_exist, v_examination_window_f1, tl_EX_rx_f);
	mg_flag_define(tl_EX_tx_wait, at_tl_EX_tx_exist, v_examination_window_f1, tl_EX_tx_f);
	mg_flag_define(tl_ME_rx_wait, at_tl_ME_rx_exist, v_examination_window_f1, tl_ME_rx_f);
	mg_flag_define(tl_ME_tx_wait, at_tl_ME_tx_exist, v_examination_window_f1, tl_ME_tx_f);
	mg_flag_define(tl_WB_rx_wait, at_tl_WB_rx_exist, v_examination_window_f1, tl_WB_rx_f);
	mg_flag_define(tl_WB_tx_wait, at_tl_WB_tx_exist, v_examination_window_f1, tl_WB_tx_f);

	mg_flag_define(t2_IF_tx_wait, at_t2_IF_tx_exist, v_examination_window_f1, t2_IF_tx_f);
	mg_flag_define(t2_ID_rx_wait, at_t2_ID_rx_exist, v_examination_window_f1, t2_ID_rx_f);
	mg_flag_define(t2_ID_tx_wait, at_t2_ID_tx_exist, v_examination_window_f1, t2_ID_tx_f);
	mg_flag_define(t2_EX_rx_wait, at_t2_EX_rx_exist, v_examination_window_f1, t2_EX_rx_f);
	mg_flag_define(t2_EX_tx_wait, at_t2_EX_tx_exist, v_examination_window_f1, t2_EX_tx_f);
	mg_flag_define(t2_ME_rx_wait, at_t2_ME_rx_exist, v_examination_window_f1, t2_ME_rx_f);
	mg_flag_define(t2_ME_tx_wait, at_t2_ME_tx_exist, v_examination_window_f1, t2_ME_tx_f);
	mg_flag_define(t2_WB_rx_wait, at_t2_WB_rx_exist, v_examination_window_f1, t2_WB_rx_f);
	mg_flag_define(t2_WB_tx_wait, at_t2_WB_tx_exist, v_examination_window_f1, t2_WB_tx_f);

	mg_flag_define(t3_IF_tx_wait, at_t3_IF_tx_exist, v_examination_window_f1, t3_IF_tx_f);
	mg_flag_define(t3_ID_rx_wait, at_t3_ID_rx_exist, v_examination_window_f1, t3_ID_rx_f);
	mg_flag_define(t3_ID_tx_wait, at_t3_ID_tx_exist, v_examination_window_f1, t3_ID_tx_f);
	mg_flag_define(t3_EX_rx_wait, at_t3_EX_rx_exist, v_examination_window_f1, t3_EX_rx_f);
	mg_flag_define(t3_EX_tx_wait, at_t3_EX_tx_exist, v_examination_window_f1, t3_EX_tx_f);
	mg_flag_define(t3_ME_rx_wait, at_t3_ME_rx_exist, v_examination_window_f1, t3_ME_rx_f);
	mg_flag_define(t3_ME_tx_wait, at_t3_ME_tx_exist, v_examination_window_f1, t3_ME_tx_f);
	mg_flag_define(t3_WB_rx_wait, at_t3_WB_rx_exist, v_examination_window_f1, t3_WB_rx_f);
	mg_flag_define(t3_WB_tx_wait, at_t3_WB_tx_exist, v_examination_window_f1, t3_WB_tx_f);

	// For debugging
	during[t,t+v_examination_window_f1]: IF_instr_enum == getInstr(m_IF_instr);
	during[t,t+v_examination_window_f1]: ID_instr_enum == getInstr(m_ID_instr);
	during[t,t+v_examination_window_f1]: EX_instr_enum == getInstr(m_EX_instr);
	during[t,t+v_examination_window_f1]: ME_instr_enum == getInstr(m_ME_instr);
	during[t,t+v_examination_window_f1]: WB_instr_enum == getInstr(m_WB_instr);

prove:
	// Prove right hook
	at t3_IF_rx_n: mg_tn_IF_rx(3);

	at t3_ID_tx_f: if (at_t3_ID_tx_exist) m_ID_instr == at_t3_IF_tx_instr endif;
	at t3_EX_tx_f: if (at_t3_EX_tx_exist) m_EX_instr == at_t3_ID_tx_instr endif;
	at t3_ME_tx_f: if (at_t3_ME_tx_exist) m_ME_instr == at_t3_EX_tx_instr endif;
	at t3_WB_tx_f: if (at_t3_WB_tx_exist) m_WB_instr == at_t3_ME_tx_instr endif;

	at t3_ID_tx_f: if (at_t3_ID_tx_exist) m_ID_pc == at_t3_IF_tx_pc endif;
	at t3_EX_tx_f: if (at_t3_EX_tx_exist) m_EX_pc == at_t3_ID_tx_pc endif;
	at t3_ME_tx_f: if (at_t3_ME_tx_exist) m_ME_pc == at_t3_EX_tx_pc endif;
	at t3_WB_tx_f: if (at_t3_WB_tx_exist) m_WB_pc == at_t3_ME_tx_pc endif;

end property;

