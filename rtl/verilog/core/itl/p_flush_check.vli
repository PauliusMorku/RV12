/*////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////                                                                 

 .d888 888                   888                        888                        888      
d88P"  888                   888                        888                        888      
888    888                   888                        888                        888      
888888 888 888  888 .d8888b  88888b.            .d8888b 88888b.   .d88b.   .d8888b 888  888 
888    888 888  888 88K      888 "88b          d88P"    888 "88b d8P  Y8b d88P"    888 .88P 
888    888 888  888 "Y8888b. 888  888          888      888  888 88888888 888      888888K  
888    888 Y88b 888      X88 888  888          Y88b.    888  888 Y8b.     Y88b.    888 "88b 
888    888  "Y88888  88888P' 888  888 88888888  "Y8888P 888  888  "Y8888   "Y8888P 888  888 
                                                                                                                                                                                                                                                                        
*/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

property flush_check;
dependencies: c_no_reset, c_no_debug, c_32bit_instr_only, c_no_st_flush, c_imem_response, c_imem_fairness, c_dmem_response, c_dmem_fairness;
for timepoints:
	t1_PF_rx_n = t + 0..v_examination_window waits_for complete mg_tn_PF_rx(1),
	t2_PF_rx_n = t + 0..v_examination_window waits_for complete mg_tn_PF_rx(2),
	t3_PF_rx_n = t + 0..v_examination_window waits_for complete mg_tn_PF_rx(3),
	t4_PF_rx_n = t + 0..v_examination_window waits_for complete mg_tn_PF_rx(4),
	t5_PF_rx_n = t + 0..v_examination_window waits_for complete mg_tn_PF_rx(5),

	t1_flush_f = t + 0..v_examination_window waits_for complete mg_tn_flush(1),
	t2_flush_f = t + 0..v_examination_window waits_for complete mg_tn_flush(2),
	t3_flush_f = t + 0..v_examination_window waits_for complete mg_tn_flush(3),
	t4_flush_f = t + 0..v_examination_window waits_for complete mg_tn_flush(4),
	t5_flush_f = t + 0..v_examination_window waits_for complete mg_tn_flush(5),

	t_dummy = t; // last dummy line (for the semicolon)

freeze:
	// Freeze signals indicating flushing cases
	at_t1_flush_exist = mg_tn_flush(1)@t1_flush_f,
	at_t2_flush_exist = mg_tn_flush(2)@t2_flush_f,
	at_t3_flush_exist = mg_tn_flush(3)@t3_flush_f,
	at_t4_flush_exist = mg_tn_flush(4)@t4_flush_f,
	at_t5_flush_exist = mg_tn_flush(5)@t5_flush_f,

	at_t_dummy = clk@t_dummy; // last dummy line (for the semicolon)

assume:
	// Property is triggered whenever a token enters first pipeline stage
	at t1_PF_rx_n: mg_tn_PF_rx(1);

	// Make sure that property does not start at flushing
	at t: !at_t1_flush_exist;

    // Configure token counters
    at t: PF_wcnt == 0;
	at t: IF_wcnt == 0;
	at t: ID_wcnt == 0;
	at t: EX_wcnt == 0;
	at t: ME_wcnt == 0;
	at t: WB_wcnt == 0;

	during[t,t+v_examination_window]: PF_wcnt_inc == m_PF_rx;
	during[t,t+v_examination_window]: IF_wcnt_inc == m_IF_rx;
	during[t,t+v_examination_window]: ID_wcnt_inc == m_ID_rx;
	during[t,t+v_examination_window]: EX_wcnt_inc == m_EX_rx;
	during[t,t+v_examination_window]: ME_wcnt_inc == m_ME_rx;
	during[t,t+v_examination_window]: WB_wcnt_inc == m_WB_rx;

	during[t,t+v_examination_window]: PF_trem == m_PF_tx;
	during[t,t+v_examination_window]: IF_trem == m_IF_tx;
	during[t,t+v_examination_window]: ID_trem == m_ID_tx;
	during[t,t+v_examination_window]: EX_trem == m_EX_tx;
	during[t,t+v_examination_window]: ME_trem == m_ME_tx;
	during[t,t+v_examination_window]: WB_trem == m_WB_tx;

	// For debugging
	during[t,t+v_examination_window]: IN_instr_enum == getInstr(if_parcel);
	during[t,t+v_examination_window]: PF_instr_enum == getInstr(m_PF_instr);
	during[t,t+v_examination_window]: IF_instr_enum == getInstr(m_IF_instr);
	during[t,t+v_examination_window]: ID_instr_enum == getInstr(m_ID_instr);
	during[t,t+v_examination_window]: EX_instr_enum == getInstr(m_EX_instr);
	during[t,t+v_examination_window]: ME_instr_enum == getInstr(m_ME_instr);
	during[t,t+v_examination_window]: WB_instr_enum == getInstr(m_WB_instr);

prove:
	at t: !at_t2_flush_exist || !at_t3_flush_exist || !at_t4_flush_exist || !at_t5_flush_exist;

	at t1_PF_rx_n: mg_tn_PF_rx(1);
	at t2_PF_rx_n: if (at_t1_flush_exist) mg_tn_PF_rx(2) endif;
	at t3_PF_rx_n: if (at_t1_flush_exist && at_t2_flush_exist) mg_tn_PF_rx(3) endif;
	at t4_PF_rx_n: if (at_t1_flush_exist && at_t2_flush_exist && at_t3_flush_exist) mg_tn_PF_rx(4) endif;
	at t5_PF_rx_n: if (at_t1_flush_exist && at_t2_flush_exist && at_t3_flush_exist && at_t4_flush_exist) mg_tn_PF_rx(5) endif;

	// Prove that counters do not overflow
	during[t,t+v_examination_window]: next(PF_wcnt) >= PF_wcnt;
	during[t,t+v_examination_window]: next(IF_wcnt) >= IF_wcnt;
	during[t,t+v_examination_window]: next(ID_wcnt) >= ID_wcnt;
	during[t,t+v_examination_window]: next(EX_wcnt) >= EX_wcnt;
	during[t,t+v_examination_window]: next(ME_wcnt) >= ME_wcnt;
	during[t,t+v_examination_window]: next(WB_wcnt) >= WB_wcnt;

end property;