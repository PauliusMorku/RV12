macro unsigned examination_window := 25 end macro;

//macro logic m_IF_rx := ((c/if_unit/id_stall == 0) && (next(c/if_unit/if_bubble) == 0)) end macro;// && (next(c/if_unit/id_stall) == 0)) end macro;
//macro logic m_ID_rx := (/*(c/id_unit/if_bubble == 0) && */(c/id_unit/stall == 0) && (c/id_unit/id_stall == 0)) end macro;
//macro logic m_EX_rx := (/*(c/ex_units/id_bubble == 0) && */(c/ex_units/ex_stall == 0)) end macro;
//macro logic m_ME_rx := ((c/mem_unit/wb_stall == 0)/* || (prev(m_EX_rx) && (c/ex_units/ex_stall == 0))*/) end macro; // either no bubble or instruction finished in EX stage (if it stalls then it is still computing)
//macro logic m_WB_rx := ((c/wb_unit/wb_stall_o == 0)/* || prev(m_ME_rx)*/) end macro;

//macro logic m_IF_tx := m_ID_rx end macro;
//macro logic m_ID_tx := m_EX_rx end macro;
//macro logic m_EX_tx := m_ME_rx end macro;
//macro logic m_ME_tx := m_WB_rx end macro;
//macro logic m_WB_tx := prev(c/wb_unit/wb_stall_o == 0) end macro;

macro logic m_IF_rx := ((c/if_unit/id_stall == 0) && (next(c/if_unit/if_bubble) == 0)) end macro;
macro logic m_ID_rx := ((c/id_unit/if_bubble == 0) && (c/id_unit/stall == 0) && (c/id_unit/id_stall == 0)) end macro;
macro logic m_EX_rx := ((c/ex_units/id_bubble == 0) && (c/ex_units/ex_stall == 0)) end macro;
macro logic m_ME_rx := ((c/mem_unit/ex_bubble == 0) && (c/mem_unit/wb_stall == 0)) end macro;
macro logic m_WB_rx := ((c/wb_unit/mem_bubble_i == 0) && (c/wb_unit/wb_stall_o == 0)) end macro;

macro logic m_IF_tx := m_ID_rx end macro;
macro logic m_ID_tx := m_EX_rx end macro;
macro logic m_EX_tx := m_ME_rx end macro;
macro logic m_ME_tx := m_WB_rx end macro;
macro logic m_WB_tx := prev(c/wb_unit/wb_stall_o == 0) end macro;

macro logic m_IF_flush := 0 end macro;
macro logic m_ID_flush := (c/ex_units/bu_flush == 1) end macro;
macro logic m_EX_flush := (c/ex_units/bu_flush == 1) end macro;
macro logic m_ME_flush := 0 end macro;
macro logic m_WB_flush := 0 end macro;

macro unsigned IF_instr := c/if_unit/if_instr end macro;
macro unsigned ID_instr := c/id_unit/id_instr end macro;
macro unsigned EX_instr := c/ex_units/ex_instr end macro;
macro unsigned ME_instr := c/mem_unit/mem_instr end macro;
macro unsigned WB_instr := c/wb_unit/wb_instr_o end macro;

macro unsigned IF_pc := c/if_unit/if_pc end macro;
macro unsigned ID_pc := c/id_unit/id_pc end macro;
macro unsigned EX_pc := c/ex_units/ex_pc end macro;
macro unsigned ME_pc := c/mem_unit/mem_pc end macro;
macro unsigned WB_pc := c/wb_unit/wb_pc_o end macro;

macro logic IF_token := true end macro;
macro logic ID_token := !c/if_unit/if_bubble end macro;
macro logic EX_token := !c/id_unit/id_bubble end macro;
macro logic ME_token := !c/ex_units/ex_bubble end macro;
macro logic WB_token := !c/mem_unit/mem_bubble end macro;

// Instruction filters are used to constrain the instructions that are read from the memory (to avoid illegal instructions and reduce computation complexity)
macro bit instr_filter1(unsigned encodedInstr) := 
	/*(getOpcode(encodedInstr) == OPCODE_I_L) ||
	(getOpcode(encodedInstr) == OPCODE_S) ||
	(getOpcode(encodedInstr) == OPCODE_I) ||*/
	(getOpcode(encodedInstr) == OPCODE_R) /*||
	(getOpcode(encodedInstr) == OPCODE_B)*/
end macro;


macro bit instr_filter2(unsigned encodedInstr) := 
	/*(getInstr(encodedInstr) == INSTR_LW) ||
	(getInstr(encodedInstr) == INSTR_SW) ||
	(getInstr(encodedInstr) == INSTR_ADDI) ||*/
	(getInstr(encodedInstr) == INSTR_ADD) /*||
	(getInstr(encodedInstr) == INSTR_BEQ)*/
end macro;

/*
macro instr_filter3(unsigned encodedInstr) := 
	(getInstr(encodedInstr) == INSTR_LW && 
	((getImmediate(encodedInstr) 	& 32'hFFFFFFFC) = 0) && 
	((getRS1Addr(encodedInstr) 		& 32'hFFFFFFFC) = 0) && 
	((getRDAddr(encodedInstr) 		& 32'hFFFFFFFC) = 0)) 
	||
	(getInstr(encodedInstr) == INSTR_SW && 
	((getImmediate(encodedInstr) 	& 32'hFFFFFFFC) = 0) && 
	((getRS1Addr(encodedInstr) 		& 32'hFFFFFFFC) = 0) && 
	((getRS2Addr(encodedInstr) 		& 32'hFFFFFFFC) = 0)) 
	||
	(getInstr(encodedInstr) == INSTR_ADDI && 
	((getImmediate(encodedInstr) 	& 32'hFFFFFFFC) = 0) &&
	((getRS1Addr(encodedInstr) 		& 32'hFFFFFFFC) = 0) &&  
	((getRDAddr(encodedInstr) 		& 32'hFFFFFFFC) = 0)) 
	||
	(getInstr(encodedInstr) == INSTR_ADD && 
	((getRS1Addr(encodedInstr) 		& 32'hFFFFFFFC) = 0) && 
	((getRS2Addr(encodedInstr)		& 32'hFFFFFFFC) = 0) && 
	((getRDAddr(encodedInstr) 		& 32'hFFFFFFFC) = 0))
	||
	(getInstr(encodedInstr) == INSTR_BEQ && 
	((getRS1Addr(encodedInstr) 		& 32'hFFFFFFFC) = 0) && 
	((getRS2Addr(encodedInstr)		& 32'hFFFFFFFC) = 0))
end macro;
*/

constraint c_no_reset :=
	c/rstn == 1;
end constraint;

constraint c_no_debug :=
	c/dbg_stall == 0 &&
	c/du_flush == 0 &&
	c/du_stall == 0 &&
	c/du_stall_dly == 0;
end constraint;

constraint c_no_st_flush :=
	((c/st_flush == 0) || prev(c/rstn == 0));
end constraint;

constraint c_no_bu_flush :=
	((c/bu_flush == 0) || prev(c/rstn == 0));
end constraint;

constraint no_if_stall_nxt_pc :=
	c/if_stall_nxt_pc == 0;
end constraint;

constraint c_if_stall_nxt_pc_fairness :=
	exists i in 0..3:
		next(c/if_stall_nxt_pc,i) == 0;
	end exists;
end constraint;

constraint if_nop :=
	c/if_instr == 32'h00000013;
end constraint;

constraint id_nop :=
	c/id_instr == 32'h00000013;
end constraint;

constraint ex_nop :=
	c/ex_instr == 32'h00000013;
end constraint;

constraint no_ex_bubble :=
	c/ex_bubble == 0;
end constraint;

constraint dmem_ready :=
	dmem_ack == 1;
end constraint;

constraint c_dmem_fairness :=
	exists i in 0..3:
		next(dmem_ack,i) == 1;
	end exists;
end constraint;

constraint c_if_parcel_valid :=
	((c/if_unit/pd_bubble == 0) || prev(c/rstn == 0) || prev(c/rstn == 0, 2)); 
end constraint;

constraint c_if_parcel_valid2 :=
	(c/if_unit/if_parcel_misaligned == 0) &&
	(c/if_unit/if_parcel_page_fault == 0);
end constraint;

constraint c_if_parcel_valid_fairness :=
	exists i in 0..4:
		next(c/if_unit/pd_bubble,i) == 0;
	end exists;
end constraint;

constraint c_no_exception :=
	c/if_exception == 0 &&
	c/ex_exception == 0 &&
	c/mem_exception == 0 &&
	c/wb_exception == 0 &&
	c/id_exception == 0;
end constraint;

constraint no_id_hazard :=
	(((c/id_unit/if_src1 != c/id_unit/id_dst) || prev(c/rstn == 0)) &&
	((c/id_unit/if_src2 != c/id_unit/id_dst) || prev(c/rstn == 0)) &&
	((c/id_unit/if_src1 != c/id_unit/ex_dst) || prev(c/rstn == 0, 2)) &&
	((c/id_unit/if_src2 != c/id_unit/ex_dst) || prev(c/rstn == 0, 2)));
end constraint;
/*
property reset;
dependencies:
	c_no_reset, c_no_debug, c_no_exception, c_no_st_flush, c_if_stall_nxt_pc_fairness, c_if_parcel_valid_fairness, c_dmem_fairness;
for timepoints:
	t1_IF_rx_n = t + 0..examination_window waits_for complete next(IF_tcnt == 1),
	t1_ID_rx_r = t + 0..examination_window waits_for complete next(ID_tcnt == 1),
	t1_EX_rx_r = t + 0..examination_window waits_for complete next(EX_tcnt == 1),
	t1_ME_rx_r = t + 0..examination_window waits_for complete next(ME_tcnt == 1),
	t1_WB_rx_r = t + 0..examination_window waits_for complete next(WB_tcnt == 1),

	t_dummy = t; // last dummy line (for the semicolon)
assume:
    reset_sequence;

    // Connect token counters
	at t: IF_tcnt == 0;
	during[t,t+examination_window]: IF_tcnt_inc == m_IF_rx;
	at t: ID_tcnt == 0;
	during[t,t+examination_window]: ID_tcnt_inc == m_ID_rx;
	at t: EX_tcnt == 0;
	during[t,t+examination_window]: EX_tcnt_inc == m_EX_rx;
	at t: ME_tcnt == 0;
	during[t,t+examination_window]: ME_tcnt_inc == m_ME_rx;
	at t: WB_tcnt == 0;
	during[t,t+examination_window]: WB_tcnt_inc == m_WB_rx;

prove:
	at t1_IF_rx_n: next(IF_tcnt == 1);
	at t1_ID_rx_r: next(ID_tcnt == 1);
	at t1_EX_rx_r: next(EX_tcnt == 1);
	at t1_ME_rx_r: next(ME_tcnt == 1);
	at t1_WB_rx_r: next(WB_tcnt == 1);
end property;
*/


// Macros that serve as helpers, eventually should be (g)enerated and not modified by the user

macro logic mg_t0_EX_rx := (m_EX_rx && next(EX_tcnt == 0) && next(!t0_ID_tx_wait)) end macro;
macro logic mg_t0_ME_rx := (m_ME_rx && next(ME_tcnt == 0) && next(!t0_EX_tx_wait)) end macro;
macro logic mg_t0_WB_rx := (m_WB_rx && next(WB_tcnt == 0) && next(!t0_ME_tx_wait)) end macro;

macro logic mg_t0_ID_tx := (m_ID_tx && (ID_tcnt == 0)) end macro;
macro logic mg_t0_EX_tx := (m_EX_tx && (EX_tcnt == 0) && !t0_EX_rx_wait) end macro;
macro logic mg_t0_ME_tx := (m_ME_tx && (ME_tcnt == 0) && !t0_ME_rx_wait) end macro;
macro logic mg_t0_WB_tx := (m_WB_tx && (WB_tcnt == 0) && !t0_WB_rx_wait) end macro;

macro logic mg_t1_IF_rx := next(IF_tcnt == 1) end macro;
macro logic mg_t1_ID_rx := next(ID_tcnt == 1) end macro;
macro logic mg_t1_EX_rx := next(EX_tcnt == 1) end macro;
macro logic mg_t1_ME_rx := next(ME_tcnt == 1) end macro;
macro logic mg_t1_WB_rx := next(WB_tcnt == 1) end macro;

macro logic mg_t1_IF_tx := (m_IF_tx && (IF_tcnt == 1)) end macro;
macro logic mg_t1_ID_tx := (m_ID_tx && (ID_tcnt == 1)) end macro;
macro logic mg_t1_EX_tx := (m_EX_tx && (EX_tcnt == 1)) end macro;
macro logic mg_t1_ME_tx := (m_ME_tx && (ME_tcnt == 1)) end macro;
macro logic mg_t1_WB_tx := (m_WB_tx && (WB_tcnt == 1)) end macro;

macro logic mg_t1_IF_flush := (m_IF_flush && (IF_tcnt == 1)) end macro;
macro logic mg_t1_ID_flush := (m_ID_flush && (ID_tcnt == 1)) end macro;
macro logic mg_t1_EX_flush := (m_EX_flush && (EX_tcnt == 1)) end macro;
macro logic mg_t1_ME_flush := (m_ME_flush && (ME_tcnt == 1)) end macro;
macro logic mg_t1_WB_flush := (m_WB_flush && (WB_tcnt == 1)) end macro;

macro logic mg_t2_IF_rx := next(IF_tcnt == 2) end macro;
macro logic mg_t2_ID_rx := next(ID_tcnt == 2) end macro;
macro logic mg_t2_EX_rx := next(EX_tcnt == 2) end macro;
macro logic mg_t2_ME_rx := next(ME_tcnt == 2) end macro;
macro logic mg_t2_WB_rx := next(WB_tcnt == 2) end macro;

macro logic mg_t2_IF_tx := (m_IF_tx && (IF_tcnt == 2)) end macro;
macro logic mg_t2_ID_tx := (m_ID_tx && (ID_tcnt == 2)) end macro;
macro logic mg_t2_EX_tx := (m_EX_tx && (EX_tcnt == 2)) end macro;
macro logic mg_t2_ME_tx := (m_ME_tx && (ME_tcnt == 2)) end macro;
macro logic mg_t2_WB_tx := (m_WB_tx && (WB_tcnt == 2)) end macro;

macro logic mg_t2_IF_flush := (m_IF_flush && (IF_tcnt == 2)) end macro;
macro logic mg_t2_ID_flush := (m_ID_flush && (ID_tcnt == 2)) end macro;
macro logic mg_t2_EX_flush := (m_EX_flush && (EX_tcnt == 2)) end macro;
macro logic mg_t2_ME_flush := (m_ME_flush && (ME_tcnt == 2)) end macro;
macro logic mg_t2_WB_flush := (m_WB_flush && (WB_tcnt == 2)) end macro;

/*
TODO:
	-try to use bubbles to ommit use of stages
	-try to match windows exactly (remove overlap)
		-hopefully by now only end of the window is not alligned


*/

property test;
dependencies: c_no_reset, c_no_debug, c_no_exception, c_no_st_flush, c_if_stall_nxt_pc_fairness, c_if_parcel_valid_fairness, c_dmem_fairness;
for timepoints:

	// t0 detection
	t0_ID_tx_f = t + 0..examination_window waits_for complete mg_t0_ID_tx,
	t0_ID_tx_l = t + 0..examination_window waits_for complete next(!t0_ID_tx_wait), // Occurance after t

	t0_EX_rx_f = t + 0..examination_window waits_for complete mg_t0_EX_rx,
	t0_EX_rx_l1 = t + 0..examination_window waits_for complete next(!t0_EX_rx_wait), // Occurance after t0_ID_tx_l
	t0_EX_rx_l = max_timepoint(t0_EX_rx_l1, t0_ID_tx_l),

	t0_EX_tx_f = t + 0..examination_window waits_for complete mg_t0_EX_tx,
	t0_EX_tx_l1 = t + 0..examination_window waits_for complete next(!t0_EX_tx_wait), // Occurance after t0_EX_rx_l1+1
	t0_EX_tx_l = max_timepoint(t0_EX_tx_l1, t0_EX_rx_l),

	t0_ME_rx_f = t + 0..examination_window waits_for complete mg_t0_ME_rx,
	t0_ME_rx_l1 = t + 0..examination_window waits_for complete next(!t0_ME_rx_wait), // Occurance after t0_EX_tx_l1
	t0_ME_rx_l = max_timepoint(t0_ME_rx_l1, t0_EX_tx_l),

	t0_ME_tx_f = t + 0..examination_window waits_for complete mg_t0_ME_tx,
	t0_ME_tx_l1 = t + 0..examination_window waits_for complete next(!t0_ME_tx_wait), // Occurance after t0_ME_rx_l1+1
	t0_ME_tx_l = max_timepoint(t0_ME_tx_l1, t0_ME_rx_l),

	t0_WB_rx_f = t + 0..examination_window waits_for complete mg_t0_WB_rx,
	t0_WB_rx_l1 = t + 0..examination_window waits_for complete next(!t0_WB_rx_wait), // Occurance after t0_ME_tx_l1
	t0_WB_rx_l = max_timepoint(t0_WB_rx_l1, t0_ME_tx_l),

	t0_WB_tx_f = t + 0..examination_window waits_for complete mg_t0_WB_tx,
	t0_WB_tx_l1 = t + 0..examination_window waits_for complete next(!t0_WB_tx_wait), // Occurance after t0_WB_rx_l1+1
	t0_WB_tx_l = max_timepoint(t0_WB_tx_l1, t0_WB_rx_l),


	// t1 detection
	t1_IF_rx_n = t,

	t1_IF_tx_r = t + 1..examination_window waits_for complete (mg_t1_IF_tx || (next(IF_tcnt) > 1)),
	t1_IF_tx_f = t + 0..examination_window waits_for complete mg_t1_IF_tx,
	t1_IF_tx_l = t + 0..examination_window waits_for complete next(!t1_IF_tx_wait),

	t1_ID_rx_f = t + 0..examination_window waits_for complete mg_t1_ID_rx,
	t1_ID_rx_l1 = t + 0..examination_window waits_for complete next(!t1_ID_rx_wait),
	t1_ID_rx_l2 = max_timepoint(t1_ID_rx_l1, t1_IF_tx_l),
	t1_ID_rx_l = max_timepoint(t1_ID_rx_l2, t0_EX_rx_l),
	t1_ID_rx_r = t1_ID_rx_f,

	t1_ID_tx_f = t + 0..examination_window waits_for complete mg_t1_ID_tx,
	t1_ID_tx_l = t + 0..examination_window waits_for complete next(!t1_ID_tx_wait),
	t1_ID_tx_r = t + 1..examination_window waits_for complete (mg_t1_ID_tx || (next(ID_tcnt) > 1)),

	t1_EX_rx_f = t + 0..examination_window waits_for complete mg_t1_EX_rx,
	t1_EX_rx_l1 = t + 0..examination_window waits_for complete next(!t1_EX_rx_wait),
	t1_EX_rx_l2 = max_timepoint(t1_EX_rx_l1, t1_ID_tx_l),
	t1_EX_rx_l = max_timepoint(t1_EX_rx_l2, t0_ME_rx_l),
	t1_EX_rx_r = t1_EX_rx_f,

	t1_EX_tx_f = t + 0..examination_window waits_for complete mg_t1_EX_tx,
	t1_EX_tx_l = t + 0..examination_window waits_for complete next(!t1_EX_tx_wait),
	t1_EX_tx_r = t + 1..examination_window waits_for complete (mg_t1_EX_tx || (next(EX_tcnt) > 1)),

	t1_ME_rx_f = t + 0..examination_window waits_for complete mg_t1_ME_rx,
	t1_ME_rx_l1 = t + 0..examination_window waits_for complete next(!t1_ME_rx_wait),
	t1_ME_rx_l2 = max_timepoint(t1_ME_rx_l1, t1_EX_tx_l),
	t1_ME_rx_l = max_timepoint(t1_ME_rx_l2, t0_WB_rx_l),
	t1_ME_rx_r = t1_ME_rx_f,

	t1_ME_tx_f = t + 0..examination_window waits_for complete mg_t1_ME_tx,
	t1_ME_tx_l = t + 0..examination_window waits_for complete next(!t1_ME_tx_wait),
	t1_ME_tx_r = t + 1..examination_window waits_for complete (mg_t1_ME_tx || (next(ME_tcnt) > 1)),

	t1_WB_rx_f = t + 0..examination_window waits_for complete mg_t1_WB_rx,
	t1_WB_rx_l1 = t + 0..examination_window waits_for complete next(!t1_WB_rx_wait),
	t1_WB_rx_l2 = max_timepoint(t1_WB_rx_l1, t1_ME_tx_l),
	t1_WB_rx_l = max_timepoint(t1_WB_rx_l2, t0_WB_tx_l), // special case since it is the last pipeline stage
	t1_WB_rx_r = t1_WB_rx_f,

	t1_WB_tx_f = t + 0..examination_window waits_for complete mg_t1_WB_tx,
	t1_WB_tx_l = t + 0..examination_window waits_for complete next(!t1_WB_tx_wait),
	t1_WB_tx_r = t + 1..examination_window waits_for complete (mg_t1_WB_tx || (next(WB_tcnt) > 1)),


	// t2 detection
	t2_IF_rx_n = t + 0..examination_window waits_for complete mg_t2_IF_rx,

	t2_IF_tx_f = t + 0..examination_window waits_for complete mg_t2_IF_tx,
	t2_IF_tx_l1 = t + 0..examination_window waits_for complete next(!t2_IF_tx_wait),
	t2_IF_tx_l = max_timepoint(t2_IF_tx_l1, t2_IF_rx_n),
	t2_IF_tx_r = t + 1..examination_window waits_for complete (mg_t2_IF_tx || (next(IF_tcnt) > 2)),

	t2_ID_rx_f = t + 0..examination_window waits_for complete mg_t2_ID_rx,
	t2_ID_rx_l1 = t + 0..examination_window waits_for complete next(!t2_ID_rx_wait),
	t2_ID_rx_l2 = max_timepoint(t2_ID_rx_l1, t2_IF_rx_n),
	t2_ID_rx_l3 = max_timepoint(t2_ID_rx_l2, t2_IF_tx_l),
	t2_ID_rx_l = max_timepoint(t2_ID_rx_l3, t1_EX_rx_l),
	t2_ID_rx_r = t2_ID_rx_f,

	t2_ID_tx_f = t + 0..examination_window waits_for complete mg_t2_ID_tx,
	t2_ID_tx_l1 = t + 0..examination_window waits_for complete next(!t2_ID_tx_wait),
	t2_ID_tx_l = max_timepoint(t2_ID_tx_l1, t2_IF_rx_n),
	t2_ID_tx_r = t + 1..examination_window waits_for complete (mg_t2_ID_tx || (next(ID_tcnt) > 2)),

	t2_EX_rx_f = t + 0..examination_window waits_for complete mg_t2_EX_rx,
	t2_EX_rx_l1 = t + 0..examination_window waits_for complete next(!t2_EX_rx_wait),
	t2_EX_rx_l2 = max_timepoint(t2_EX_rx_l1, t2_IF_rx_n),
	t2_EX_rx_l3 = max_timepoint(t2_EX_rx_l2, t2_ID_tx_l),
	t2_EX_rx_l = max_timepoint(t2_EX_rx_l3, t1_ME_rx_l),
	t2_EX_rx_r = t2_EX_rx_f,

	t2_EX_tx_f = t + 0..examination_window waits_for complete mg_t2_EX_tx,
	t2_EX_tx_l1 = t + 0..examination_window waits_for complete next(!t2_EX_tx_wait),
	t2_EX_tx_l = max_timepoint(t2_EX_tx_l1, t2_IF_rx_n),
	t2_EX_tx_r = t + 1..examination_window waits_for complete (mg_t2_EX_tx || (next(EX_tcnt) > 2)),

	t2_ME_rx_f = t + 0..examination_window waits_for complete mg_t2_ME_rx,
	t2_ME_rx_l1 = t + 0..examination_window waits_for complete next(!t2_ME_rx_wait),
	t2_ME_rx_l2 = max_timepoint(t2_ME_rx_l1, t2_IF_rx_n),
	t2_ME_rx_l3 = max_timepoint(t2_ME_rx_l2, t2_EX_tx_l),
	t2_ME_rx_l = max_timepoint(t2_ME_rx_l3, t1_WB_rx_l),
	t2_ME_rx_r = t2_ME_rx_f,

	t2_ME_tx_f = t + 0..examination_window waits_for complete mg_t2_ME_tx,
	t2_ME_tx_l1 = t + 0..examination_window waits_for complete next(!t2_ME_tx_wait),
	t2_ME_tx_l = max_timepoint(t2_ME_tx_l1, t2_IF_rx_n),
	t2_ME_tx_r = t + 1..examination_window waits_for complete (mg_t2_ME_tx || (next(ME_tcnt) > 2)),

	t2_WB_rx_f = t + 0..examination_window waits_for complete mg_t2_WB_rx,
	t2_WB_rx_l1 = t + 0..examination_window waits_for complete next(!t2_WB_rx_wait),
	t2_WB_rx_l2 = max_timepoint(t2_WB_rx_l1, t2_IF_rx_n),
	t2_WB_rx_l3 = max_timepoint(t2_WB_rx_l2, t2_ME_tx_l),
	t2_WB_rx_l = max_timepoint(t2_WB_rx_l3, t1_WB_tx_l), // special case since it is the last pipeline stage
	t2_WB_rx_r = t2_WB_rx_f,

	t2_WB_tx_r = t + 1..examination_window waits_for complete (mg_t2_WB_tx || (next(WB_tcnt) > 2)),


	// Detect flushing cases
	t1_IF_flush = t + 0..examination_window waits_for complete mg_t1_IF_flush,
	t1_ID_flush = t + 0..examination_window waits_for complete mg_t1_ID_flush,
	t1_EX_flush = t + 0..examination_window waits_for complete mg_t1_EX_flush,
	t1_ME_flush = t + 0..examination_window waits_for complete mg_t1_ME_flush,
	t1_WB_flush = t + 0..examination_window waits_for complete mg_t1_WB_flush,

	t2_IF_flush = t + 0..examination_window waits_for complete mg_t2_IF_flush,
	t2_ID_flush = t + 0..examination_window waits_for complete mg_t2_ID_flush,
	t2_EX_flush = t + 0..examination_window waits_for complete mg_t2_EX_flush,
	t2_ME_flush = t + 0..examination_window waits_for complete mg_t2_ME_flush,
	t2_WB_flush = t + 0..examination_window waits_for complete mg_t2_WB_flush,

	t_dummy = t; // last dummy line (for the semicolon)

freeze:
	at_t0_ID_tx_exist = mg_t0_ID_tx@t0_ID_tx_f,
	at_t0_EX_rx_exist = mg_t0_EX_rx@t0_EX_rx_f,
	at_t0_EX_tx_exist = mg_t0_EX_tx@t0_EX_tx_f,
	at_t0_ME_rx_exist = mg_t0_ME_rx@t0_ME_rx_f,
	at_t0_ME_tx_exist = mg_t0_ME_tx@t0_ME_tx_f,
	at_t0_WB_rx_exist = mg_t0_WB_rx@t0_WB_rx_f,
	at_t0_WB_tx_exist = mg_t0_WB_tx@t0_WB_tx_f,

	at_t1_IF_tx_exist = mg_t1_IF_tx@t1_IF_tx_f,
	at_t1_ID_rx_exist = mg_t1_ID_rx@t1_ID_rx_f,
	at_t1_ID_tx_exist = mg_t1_ID_tx@t1_ID_tx_f,
	at_t1_EX_rx_exist = mg_t1_EX_rx@t1_EX_rx_f,
	at_t1_EX_tx_exist = mg_t1_EX_tx@t1_EX_tx_f,
	at_t1_ME_rx_exist = mg_t1_ME_rx@t1_ME_rx_f,
	at_t1_ME_tx_exist = mg_t1_ME_tx@t1_ME_tx_f,
	at_t1_WB_rx_exist = mg_t1_WB_rx@t1_WB_rx_f,
	at_t1_WB_tx_exist = mg_t1_WB_tx@t1_WB_tx_f,

	at_t2_IF_tx_exist = mg_t2_IF_tx@t2_IF_tx_f,
	at_t2_ID_rx_exist = mg_t2_ID_rx@t2_ID_rx_f,
	at_t2_ID_tx_exist = mg_t2_ID_tx@t2_ID_tx_f,
	at_t2_EX_rx_exist = mg_t2_EX_rx@t2_EX_rx_f,
	at_t2_EX_tx_exist = mg_t2_EX_tx@t2_EX_tx_f,
	at_t2_ME_rx_exist = mg_t2_ME_rx@t2_ME_rx_f,
	at_t2_ME_tx_exist = mg_t2_ME_tx@t2_ME_tx_f,
	at_t2_WB_rx_exist = mg_t2_WB_rx@t2_WB_rx_f,

	// Freeze signals indicating flushing cases
	at_t1_IF_flush = mg_t1_IF_flush@t1_IF_flush,
	at_t1_ID_flush = mg_t1_ID_flush@t1_ID_flush,
	at_t1_EX_flush = mg_t1_EX_flush@t1_EX_flush,
	at_t1_ME_flush = mg_t1_ME_flush@t1_ME_flush,
	at_t1_WB_flush = mg_t1_WB_flush@t1_WB_flush,

	at_t2_IF_flush = mg_t2_IF_flush@t2_IF_flush,
	at_t2_ID_flush = mg_t2_ID_flush@t2_ID_flush,
	at_t2_EX_flush = mg_t2_EX_flush@t2_EX_flush,
	at_t2_ME_flush = mg_t2_ME_flush@t2_ME_flush,
	at_t2_WB_flush = mg_t2_WB_flush@t2_WB_flush,


	at_t2_IF_tx_instr = IF_instr@t2_IF_tx_r,
	at_t2_ID_tx_instr = ID_instr@t2_ID_tx_r,
	at_t2_EX_tx_instr = EX_instr@t2_EX_tx_r,
	at_t2_ME_tx_instr = ME_instr@t2_ME_tx_r,
	at_t2_WB_tx_instr = WB_instr@t2_WB_tx_r,

	at_t2_IF_tx_pc = IF_pc@t2_IF_tx_r,
	at_t2_ID_tx_pc = ID_pc@t2_ID_tx_r,
	at_t2_EX_tx_pc = EX_pc@t2_EX_tx_r,
	at_t2_ME_tx_pc = ME_pc@t2_ME_tx_r,
	at_t2_WB_tx_pc = WB_pc@t2_WB_tx_r,

	at_t_dummy = clk@t_dummy; // last dummy line (for the semicolon)

assume:
	// Property is triggered whenever a token successfully traverses the pipeline with no flushing
	at t1_IF_rx_n: mg_t1_IF_rx;

	// Connect token counters
	at t: IF_tcnt == 0;
	during[t,t+examination_window]: IF_tcnt_inc == m_IF_rx;
	at t: ID_tcnt == 0;
	during[t,t+examination_window]: ID_tcnt_inc == m_ID_rx;
	at t: EX_tcnt == 0;
	during[t,t+examination_window]: EX_tcnt_inc == m_EX_rx;
	at t: ME_tcnt == 0;
	during[t,t+examination_window]: ME_tcnt_inc == m_ME_rx;
	at t: WB_tcnt == 0;
	during[t,t+examination_window]: WB_tcnt_inc == m_WB_rx;


	// Detect token flushing
	during[t,t+examination_window]: t1_flush == (at_t1_IF_flush || at_t1_ID_flush || at_t1_EX_flush || at_t1_ME_flush || at_t1_WB_flush);
	during[t,t+examination_window]: t2_flush == (at_t2_IF_flush || at_t2_ID_flush || at_t2_EX_flush || at_t2_ME_flush || at_t2_WB_flush);
	//during[t,t+examination_window]: t3_flush == (at_t3_IF_flush || at_t3_ID_flush || at_t3_EX_flush || at_t3_ME_flush || at_t3_WB_flush);


	// Helper variable to determine if event occured within examination_window
	//during[t,t+examination_window]: within_window == true;
	//at t+examination_window+1: within_window == false;



	during[t,t0_ID_tx_f]: t0_ID_tx_wait == at_t0_ID_tx_exist;
	during[t0_ID_tx_f+1,t+examination_window]: !t0_ID_tx_wait;

	during[t,t0_EX_rx_f]: t0_EX_rx_wait == at_t0_EX_rx_exist;
	during[t0_EX_rx_f+1,t+examination_window]: !t0_EX_rx_wait;

	during[t,t0_EX_tx_f]: t0_EX_tx_wait == at_t0_EX_tx_exist;
	during[t0_EX_tx_f+1,t+examination_window]: !t0_EX_tx_wait;

	during[t,t0_ME_rx_f]: t0_ME_rx_wait == at_t0_ME_rx_exist;
	during[t0_ME_rx_f+1,t+examination_window]: !t0_ME_rx_wait;	

	during[t,t0_ME_tx_f]: t0_ME_tx_wait == at_t0_ME_tx_exist;
	during[t0_ME_tx_f+1,t+examination_window]: !t0_ME_tx_wait;

	during[t,t0_WB_rx_f]: t0_WB_rx_wait == at_t0_WB_rx_exist;
	during[t0_WB_rx_f+1,t+examination_window]: !t0_WB_rx_wait;	

	during[t,t0_WB_tx_f]: t0_WB_tx_wait == at_t0_WB_tx_exist;
	during[t0_WB_tx_f+1,t+examination_window]: !t0_WB_tx_wait;


	during[t,t1_IF_tx_f]: t1_IF_tx_wait == at_t1_IF_tx_exist;
	during[t1_IF_tx_f+1,t+examination_window]: !t1_IF_tx_wait;

	during[t,t1_ID_rx_f]: t1_ID_rx_wait == at_t1_ID_rx_exist;
	during[t1_ID_rx_f+1,t+examination_window]: !t1_ID_rx_wait;

	during[t,t1_ID_tx_f]: t1_ID_tx_wait == at_t1_ID_tx_exist;
	during[t1_ID_tx_f+1,t+examination_window]: !t1_ID_tx_wait;

	during[t,t1_EX_rx_f]: t1_EX_rx_wait == at_t1_EX_rx_exist;
	during[t1_EX_rx_f+1,t+examination_window]: !t1_EX_rx_wait;

	during[t,t1_EX_tx_f]: t1_EX_tx_wait == at_t1_EX_tx_exist;
	during[t1_EX_tx_f+1,t+examination_window]: !t1_EX_tx_wait;

	during[t,t1_ME_rx_f]: t1_ME_rx_wait == at_t1_ME_rx_exist;
	during[t1_ME_rx_f+1,t+examination_window]: !t1_ME_rx_wait;

	during[t,t1_ME_tx_f]: t1_ME_tx_wait == at_t1_ME_tx_exist;
	during[t1_ME_tx_f+1,t+examination_window]: !t1_ME_tx_wait;	

	during[t,t1_WB_rx_f]: t1_WB_rx_wait == at_t1_WB_rx_exist;
	during[t1_WB_rx_f+1,t+examination_window]: !t1_WB_rx_wait;

	during[t,t1_WB_tx_f]: t1_WB_tx_wait == at_t1_WB_tx_exist;
	during[t1_WB_tx_f+1,t+examination_window]: !t1_WB_tx_wait;


	during[t,t2_IF_tx_f]: t2_IF_tx_wait == at_t2_IF_tx_exist;
	during[t2_IF_tx_f+1,t+examination_window]: !t2_IF_tx_wait;

	during[t,t2_ID_rx_f]: t2_ID_rx_wait == at_t2_ID_rx_exist;
	during[t2_ID_rx_f+1,t+examination_window]: !t2_ID_rx_wait;

	during[t,t2_ID_tx_f]: t2_ID_tx_wait == at_t2_ID_tx_exist;
	during[t2_ID_tx_f+1,t+examination_window]: !t2_ID_tx_wait;

	during[t,t2_EX_rx_f]: t2_EX_rx_wait == at_t2_EX_rx_exist;
	during[t2_EX_rx_f+1,t+examination_window]: !t2_EX_rx_wait;

	during[t,t2_EX_tx_f]: t2_EX_tx_wait == at_t2_EX_tx_exist;
	during[t2_EX_tx_f+1,t+examination_window]: !t2_EX_tx_wait;

	during[t,t2_ME_rx_f]: t2_ME_rx_wait == at_t2_ME_rx_exist;
	during[t2_ME_rx_f+1,t+examination_window]: !t2_ME_rx_wait;

	during[t,t2_ME_tx_f]: t2_ME_tx_wait == at_t2_ME_tx_exist;
	during[t2_ME_tx_f+1,t+examination_window]: !t2_ME_tx_wait;	

	during[t,t2_WB_rx_f]: t2_WB_rx_wait == at_t2_WB_rx_exist;
	during[t2_WB_rx_f+1,t+examination_window]: !t2_WB_rx_wait;



	//within[t,t+examination_window]: t0_WB_tx_wait == true;



	// Make sure that property does not start at flushing and no flushing occur withing the window
	at t: t1_flush == 0;
	at t: t2_flush == 0;
	//at t: t3_flush == 0;

prove:
	true;

	at t2_IF_rx_n: mg_t2_IF_rx;
/*
	at t2_ID_tx_r: ID_instr == at_t2_IF_tx_instr;
	at t2_EX_tx_r: EX_instr == at_t2_ID_tx_instr;
	at t2_ME_tx_r: ME_instr == at_t2_EX_tx_instr;
	at t2_WB_tx_r: WB_instr == at_t2_ME_tx_instr;

	at t2_ID_tx_r: ID_pc == at_t2_IF_tx_pc;
	at t2_EX_tx_r: EX_pc == at_t2_ID_tx_pc;
	at t2_ME_tx_r: ME_pc == at_t2_EX_tx_pc;
	at t2_WB_tx_r: WB_pc == at_t2_ME_tx_pc;


	// Prove that events take place
	at t1_IF_tx_r: mg_t1_IF_tx;
	at t1_ID_tx_r: mg_t1_ID_tx;
	at t1_EX_tx_r: mg_t1_EX_tx;
	at t1_ME_tx_r: mg_t1_ME_tx;
	at t1_WB_tx_r: mg_t1_WB_tx;
*/
	// Prove right hook
	at t2_IF_rx_n: mg_t2_IF_rx;
	at t2_IF_tx_r: mg_t2_IF_tx;
	at t2_ID_rx_l: mg_t2_ID_rx;
	at t2_ID_tx_r: mg_t2_ID_tx;
	at t2_EX_rx_l: mg_t2_EX_rx;
	at t2_EX_tx_r: mg_t2_EX_tx;
	at t2_ME_rx_l: mg_t2_ME_rx;
	at t2_ME_tx_r: mg_t2_ME_tx;
	at t2_WB_rx_l: mg_t2_WB_rx;
	at t2_WB_tx_r: mg_t2_WB_tx;


end property;
